<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <meta content="text/html; charset=UTF-8" http-equiv="Content-Type" />

  <title>Class: Back</title>

  <link rel="stylesheet" href="./rdoc.css" type="text/css" media="screen" />

  <script src="./js/jquery.js" type="text/javascript" charset="utf-8"></script>
  <script src="./js/thickbox-compressed.js" type="text/javascript" charset="utf-8"></script>
  <script src="./js/quicksearch.js" type="text/javascript" charset="utf-8"></script>
  <script src="./js/darkfish.js" type="text/javascript" charset="utf-8"></script>

</head>
<body id="top" class="class">

  <div id="metadata">
    <div id="home-metadata">
      <div id="home-section" class="section">
        <h3 class="section-header">
          <a href="./index.html">Home</a>
          <a href="./index.html#classes">Classes</a>
          <a href="./index.html#methods">Methods</a>
        </h3>
      </div>
    </div>

    <div id="file-metadata">
      <div id="file-list-section" class="section">
        <h3 class="section-header">In Files</h3>
        <div class="section-body">
          <ul>
          
            <li><a href="./sigpa/python/back_rb.html?TB_iframe=true&amp;height=550&amp;width=785"
              class="thickbox" title="sigpa/python/back.rb">sigpa/python/back.rb</a></li>
          
            <li><a href="./sigpa/linx4py/back_rb.html?TB_iframe=true&amp;height=550&amp;width=785"
              class="thickbox" title="sigpa/linx4py/back.rb">sigpa/linx4py/back.rb</a></li>
          
          </ul>
        </div>
      </div>

      
    </div>

    <div id="class-metadata">
      
      <!-- Parent Class -->
      <div id="parent-class-section" class="section">
        <h3 class="section-header">Parent</h3>
        
        <p class="link"><a href="Object.html">Object</a></p>
        
      </div>
      

      

      

      
      <!-- Method Quickref -->
      <div id="method-list-section" class="section">
        <h3 class="section-header">Methods</h3>
        <ul class="link-list">
          
          <li><a href="#method-i-baseref_name">#baseref_name</a></li>
          
          <li><a href="#method-i-compute_padding">#compute_padding</a></li>
          
          <li><a href="#method-i-create_tree">#create_tree</a></li>
          
          <li><a href="#method-i-decorate_grove">#decorate_grove</a></li>
          
          <li><a href="#method-i-generate_signal_classes">#generate_signal_classes</a></li>
          
          <li><a href="#method-i-generate_signal_description">#generate_signal_description</a></li>
          
          <li><a href="#method-i-ind">#ind</a></li>
          
          <li><a href="#method-i-insert_padding">#insert_padding</a></li>
          
          <li><a href="#method-i-is_numeric-3F">#is_numeric?</a></li>
          
          <li><a href="#method-i-item_basetype">#item_basetype</a></li>
          
          <li><a href="#method-i-item_name">#item_name</a></li>
          
          <li><a href="#method-i-item_type">#item_type</a></li>
          
          <li><a href="#method-i-list_grove">#list_grove</a></li>
          
          <li><a href="#method-i-make_grove">#make_grove</a></li>
          
        </ul>
      </div>
      

      
    </div>

    <div id="project-metadata">
      
      
      <div id="fileindex-section" class="section project-section">
        <h3 class="section-header">Files</h3>
        <ul>
        
          <li class="file"><a href="./sigpa/Rakefile.html">Rakefile</a></li>
        
          <li class="file"><a href="./sigpa/test/ref/ref_processed_cppstr_txt.html">ref_processed_cppstr.txt</a></li>
        
          <li class="file"><a href="./testpa/Rakefile.html">Rakefile</a></li>
        
          <li class="file"><a href="./testpa/test/ref/abstractTC_template_txt.html">abstractTC_template.txt</a></li>
        
          <li class="file"><a href="./testpa/test/ref/ref_abstracttestcase_txt.html">ref_abstracttestcase.txt</a></li>
        
          <li class="file"><a href="./testpa/test/ref/ref_comment_txt.html">ref_comment.txt</a></li>
        
          <li class="file"><a href="./testpa/test/ref/transistion_template_txt.html">transistion_template.txt</a></li>
        
        </ul>
      </div>
      

      <div id="classindex-section" class="section project-section">
        <h3 class="section-header">Class/Module Index
          <span class="search-toggle"><img src="./images/find.png"
            height="16" width="16" alt="[+]"
            title="show/hide quicksearch" /></span></h3>
        <form action="#" method="get" accept-charset="utf-8" class="initially-hidden">
        <fieldset>
          <legend>Quicksearch</legend>
          <input type="text" name="quicksearch" value=""
            class="quicksearch-field" />
        </fieldset>
        </form>

        <ul class="link-list">
        
          <li><a href="./ArgumentCheck.html">ArgumentCheck</a></li>
        
          <li><a href="./Back.html">Back</a></li>
        
          <li><a href="./Consumer.html">Consumer</a></li>
        
          <li><a href="./Crubyparse.html">Crubyparse</a></li>
        
          <li><a href="./Front.html">Front</a></li>
        
          <li><a href="./GetRef.html">GetRef</a></li>
        
          <li><a href="./Kernel.html">Kernel</a></li>
        
          <li><a href="./Object.html">Object</a></li>
        
          <li><a href="./ParseCommandLine.html">ParseCommandLine</a></li>
        
          <li><a href="./Printoptions.html">Printoptions</a></li>
        
          <li><a href="./ReadFile.html">ReadFile</a></li>
        
          <li><a href="./Regtally.html">Regtally</a></li>
        
          <li><a href="./SignalClass.html">SignalClass</a></li>
        
          <li><a href="./String.html">String</a></li>
        
          <li><a href="./SyntaxDescription.html">SyntaxDescription</a></li>
        
          <li><a href="./TC_Back.html">TC_Back</a></li>
        
          <li><a href="./TC_Emit.html">TC_Emit</a></li>
        
          <li><a href="./TC_Front.html">TC_Front</a></li>
        
          <li><a href="./TC_Linx4PyBack.html">TC_Linx4PyBack</a></li>
        
          <li><a href="./TC_Linx4PyEmit.html">TC_Linx4PyEmit</a></li>
        
          <li><a href="./TC_Linx4PySigpaUser.html">TC_Linx4PySigpaUser</a></li>
        
          <li><a href="./TC_Linx4PyUser.html">TC_Linx4PyUser</a></li>
        
          <li><a href="./TC_SigpaFront.html">TC_SigpaFront</a></li>
        
          <li><a href="./TC_SigpaUser.html">TC_SigpaUser</a></li>
        
          <li><a href="./TC_TCrubyparse.html">TC_TCrubyparse</a></li>
        
          <li><a href="./TC_TestCaseBack.html">TC_TestCaseBack</a></li>
        
          <li><a href="./TC_TestUser.html">TC_TestUser</a></li>
        
          <li><a href="./TC_Tree.html">TC_Tree</a></li>
        
          <li><a href="./TCrubyparse.html">TCrubyparse</a></li>
        
          <li><a href="./TestCaseBack.html">TestCaseBack</a></li>
        
          <li><a href="./Tree.html">Tree</a></li>
        
        </ul>
        <div id="no-class-search-results" style="display: none;">No matching classes.</div>
      </div>

      
    </div>
  </div>

  <div id="documentation">
    <h1 class="class">Back</h1>

    <div id="description" class="description">
      
    </div><!-- description -->

    
    
    
    <div id="5Buntitled-5D" class="documentation-section">
      

      

      

      

      <!-- Methods -->
      
      <div id="public-instance-method-details" class="method-section section">
        <h3 class="section-header">Public Instance Methods</h3>

      
        <div id="baseref_name-method" class="method-detail ">
          <a name="method-i-baseref_name"></a>

          
          <div class="method-heading">
            <span class="method-name">baseref_name</span><span
              class="method-args">(elem)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            
            

            
            <div class="method-source-code" id="baseref_name-source">
<pre>
<span class="ruby-comment"># File sigpa/python/back.rb, line 87</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">baseref_name</span>(<span class="ruby-identifier">elem</span>)
  <span class="ruby-identifier">elem</span>[<span class="ruby-value">1</span>][<span class="ruby-string">&quot;.base_ref_name&quot;</span>] <span class="ruby-operator">=~</span> <span class="ruby-regexp">/\((.+)\): (\w+)/</span>
  <span class="ruby-node">$2</span>.<span class="ruby-identifier">clone</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- baseref_name-source -->
            
          </div>

          

          
        </div><!-- baseref_name-method -->

      
        <div id="compute_padding-method" class="method-detail ">
          <a name="method-i-compute_padding"></a>

          
          <div class="method-heading">
            <span class="method-name">compute_padding</span><span
              class="method-args">(offset, alignment)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Compute padding</p>
            

            
            <div class="method-source-code" id="compute_padding-source">
<pre>
<span class="ruby-comment"># File sigpa/python/back.rb, line 191</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">compute_padding</span>(<span class="ruby-identifier">offset</span>, <span class="ruby-identifier">alignment</span>)
  <span class="ruby-identifier">misalign</span> = <span class="ruby-identifier">offset</span> <span class="ruby-operator">%</span> <span class="ruby-identifier">alignment</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">misalign</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">0</span>
    <span class="ruby-identifier">alignment</span> <span class="ruby-operator">-</span> <span class="ruby-identifier">misalign</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-value">0</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- compute_padding-source -->
            
          </div>

          

          
        </div><!-- compute_padding-method -->

      
        <div id="create_tree-method" class="method-detail ">
          <a name="method-i-create_tree"></a>

          
          <div class="method-heading">
            <span class="method-name">create_tree</span><span
              class="method-args">(node, elem, level, parent)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Create a parse tree, i.e. a representation of a single nested data
structure in tree form.</p>
            

            
            <div class="method-source-code" id="create_tree-source">
<pre>
<span class="ruby-comment"># File sigpa/python/back.rb, line 101</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">create_tree</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">elem</span>, <span class="ruby-identifier">level</span>, <span class="ruby-identifier">parent</span>)
  <span class="ruby-identifier">node</span>.<span class="ruby-identifier">level</span> = <span class="ruby-identifier">level</span>
  <span class="ruby-identifier">node</span>.<span class="ruby-identifier">data</span> = <span class="ruby-constant">Set</span>.<span class="ruby-identifier">new</span>([])
  <span class="ruby-identifier">etype</span> = <span class="ruby-identifier">item_type</span>(<span class="ruby-identifier">elem</span>)

  <span class="ruby-keyword">if</span> <span class="ruby-identifier">etype</span> <span class="ruby-operator">=~</span> <span class="ruby-regexp">/array/</span>
    <span class="ruby-identifier">node</span>.<span class="ruby-identifier">kind</span> = <span class="ruby-string">&quot;array&quot;</span>
    <span class="ruby-identifier">node</span>.<span class="ruby-identifier">arrsize</span> = <span class="ruby-identifier">elem</span>[<span class="ruby-value">1</span>][<span class="ruby-string">&quot;.array_size&quot;</span>].<span class="ruby-identifier">to_i</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">elem</span>[<span class="ruby-value">1</span>].<span class="ruby-identifier">has_key?</span>(<span class="ruby-string">&quot;.subtype&quot;</span>) <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">elem</span>[<span class="ruby-value">1</span>][<span class="ruby-string">&quot;.subtype&quot;</span>].<span class="ruby-identifier">has_key?</span>(<span class="ruby-string">&quot;.members&quot;</span>)
      <span class="ruby-identifier">elem</span>[<span class="ruby-value">1</span>][<span class="ruby-string">&quot;.subtype&quot;</span>][<span class="ruby-string">&quot;.members&quot;</span>].<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">m</span><span class="ruby-operator">|</span>
        <span class="ruby-identifier">x</span> = <span class="ruby-constant">Tree</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">m</span>[<span class="ruby-value">0</span>], <span class="ruby-identifier">item_type</span>(<span class="ruby-identifier">elem</span>), <span class="ruby-identifier">node</span>)
        <span class="ruby-identifier">node</span>.<span class="ruby-identifier">create_child</span>(<span class="ruby-identifier">x</span>)
        <span class="ruby-identifier">create_tree</span>(<span class="ruby-identifier">x</span>, <span class="ruby-identifier">m</span>, <span class="ruby-identifier">level</span><span class="ruby-operator">+</span><span class="ruby-value">1</span>, <span class="ruby-identifier">node</span>)
      <span class="ruby-keyword">end</span>
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">elem</span>[<span class="ruby-value">1</span>][<span class="ruby-string">&quot;.subtype&quot;</span>].<span class="ruby-identifier">has_key?</span>(<span class="ruby-string">&quot;.type_or_id_name&quot;</span>)
        <span class="ruby-identifier">elem</span>[<span class="ruby-value">1</span>][<span class="ruby-string">&quot;.subtype&quot;</span>][<span class="ruby-string">&quot;.type_or_id_name&quot;</span>] <span class="ruby-operator">=~</span> <span class="ruby-regexp">/\((.+)\): (\w+)/</span>
        <span class="ruby-identifier">node</span>.<span class="ruby-identifier">s_u_name</span> = <span class="ruby-node">$2</span>.<span class="ruby-identifier">clone</span>
      <span class="ruby-keyword">else</span>
        <span class="ruby-identifier">node</span>.<span class="ruby-identifier">s_u_name</span> = <span class="ruby-string">&quot;__ANON__&quot;</span>
      <span class="ruby-keyword">end</span>
      <span class="ruby-identifier">node</span>.<span class="ruby-identifier">data</span> = <span class="ruby-identifier">elem</span>[<span class="ruby-value">1</span>][<span class="ruby-string">&quot;.subtype&quot;</span>][<span class="ruby-string">&quot;.type&quot;</span>] 
    <span class="ruby-keyword">else</span>
      <span class="ruby-identifier">sign</span> = <span class="ruby-string">&quot;signed&quot;</span>
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">elem</span>[<span class="ruby-value">1</span>][<span class="ruby-string">&quot;.subtype&quot;</span>].<span class="ruby-identifier">has_key?</span>(<span class="ruby-string">&quot;.signed&quot;</span>)
        <span class="ruby-identifier">sign</span> = <span class="ruby-identifier">elem</span>[<span class="ruby-value">1</span>][<span class="ruby-string">&quot;.subtype&quot;</span>][<span class="ruby-string">&quot;.signed&quot;</span>]
      <span class="ruby-keyword">end</span>
      <span class="ruby-identifier">type</span> = <span class="ruby-identifier">elem</span>[<span class="ruby-value">1</span>][<span class="ruby-string">&quot;.subtype&quot;</span>][<span class="ruby-string">&quot;.type&quot;</span>]
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">type</span> <span class="ruby-operator">==</span> <span class="ruby-string">&quot;enum&quot;</span> 
        <span class="ruby-identifier">node</span>.<span class="ruby-identifier">basetype</span> = <span class="ruby-string">'S32'</span>
      <span class="ruby-keyword">else</span>
        <span class="ruby-identifier">node</span>.<span class="ruby-identifier">basetype</span> = <span class="ruby-identifier">@@basetypes</span>[<span class="ruby-identifier">sign</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">type</span>]
      <span class="ruby-keyword">end</span>
      <span class="ruby-identifier">node</span>.<span class="ruby-identifier">leaf</span> = <span class="ruby-keyword">true</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">etype</span> <span class="ruby-operator">=~</span> <span class="ruby-regexp">/struct|union/</span>
    <span class="ruby-identifier">node</span>.<span class="ruby-identifier">kind</span> = <span class="ruby-node">$&amp;</span>
    <span class="ruby-identifier">node</span>.<span class="ruby-identifier">s_u_name</span> = <span class="ruby-identifier">item_name</span>(<span class="ruby-identifier">elem</span>)
    <span class="ruby-identifier">elem</span>[<span class="ruby-value">1</span>][<span class="ruby-string">&quot;.members&quot;</span>].<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">m</span><span class="ruby-operator">|</span>
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">m</span>[<span class="ruby-value">1</span>][<span class="ruby-string">&quot;.type&quot;</span>].<span class="ruby-identifier">eql?</span>(<span class="ruby-string">&quot;error&quot;</span>)  
       <span class="ruby-comment"># Ignore illegal line from signal struct, extended by jf2508</span>
       <span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;#{m[0]}, .type = #{m[1][&quot;.type&quot;]}, ignored&quot;</span>
      <span class="ruby-keyword">else</span> 
       <span class="ruby-identifier">x</span> = <span class="ruby-constant">Tree</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">m</span>[<span class="ruby-value">0</span>], <span class="ruby-identifier">item_type</span>(<span class="ruby-identifier">elem</span>), <span class="ruby-identifier">node</span>)
       <span class="ruby-identifier">node</span>.<span class="ruby-identifier">create_child</span>(<span class="ruby-identifier">x</span>)
       <span class="ruby-identifier">create_tree</span>(<span class="ruby-identifier">x</span>, <span class="ruby-identifier">m</span>, <span class="ruby-identifier">level</span><span class="ruby-operator">+</span><span class="ruby-value">1</span>, <span class="ruby-identifier">node</span>)
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">etype</span> <span class="ruby-operator">=~</span> <span class="ruby-regexp">/enum/</span>
    <span class="ruby-identifier">node</span>.<span class="ruby-identifier">kind</span> = <span class="ruby-string">&quot;enum&quot;</span>
    <span class="ruby-identifier">node</span>.<span class="ruby-identifier">basetype</span> = <span class="ruby-string">&quot;S32&quot;</span>
    <span class="ruby-identifier">node</span>.<span class="ruby-identifier">parent</span> = <span class="ruby-identifier">parent</span>
    <span class="ruby-identifier">node</span>.<span class="ruby-identifier">leaf</span> = <span class="ruby-keyword">true</span>
  <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">is_numeric?</span>(<span class="ruby-identifier">elem</span>)
    <span class="ruby-identifier">node</span>.<span class="ruby-identifier">kind</span> = <span class="ruby-string">&quot;numeric&quot;</span>
    <span class="ruby-identifier">node</span>.<span class="ruby-identifier">basetype</span> = <span class="ruby-identifier">item_basetype</span>(<span class="ruby-identifier">elem</span>)
    <span class="ruby-identifier">node</span>.<span class="ruby-identifier">parent</span> = <span class="ruby-identifier">parent</span>
    <span class="ruby-identifier">node</span>.<span class="ruby-identifier">leaf</span> = <span class="ruby-keyword">true</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">raise</span> <span class="ruby-node">&quot;Node #{node.name} contains erroneous data&quot;</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- create_tree-source -->
            
          </div>

          

          
        </div><!-- create_tree-method -->

      
        <div id="decorate_grove-method" class="method-detail ">
          <a name="method-i-decorate_grove"></a>

          
          <div class="method-heading">
            <span class="method-name">decorate_grove</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Decorate trees in grove, i.e. update nodes with pertinent information.
Since structs have to be aligned based on the alignment requirements of
their largest member, we update all such data structures recursively from
bottom up, allowing the max size to percolate upwards in the tree. The
‘sigNo’ member, however, must be excluded from the calculation of ‘size’
for root, so the  latter has to be recalculated. Placeholders for anonymous
structs and unions are replaced with unique names.</p>
            

            
            <div class="method-source-code" id="decorate_grove-source">
<pre>
<span class="ruby-comment"># File sigpa/python/back.rb, line 257</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">decorate_grove</span>()
  <span class="ruby-identifier">@@grove</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">a</span>,<span class="ruby-identifier">b</span><span class="ruby-operator">|</span>
    <span class="ruby-ivar">@extcount</span> = <span class="ruby-value">1</span>
    <span class="ruby-constant">Tree</span>.<span class="ruby-identifier">postorder</span>(<span class="ruby-identifier">b</span>[<span class="ruby-string">&quot;tree&quot;</span>]) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">n</span><span class="ruby-operator">|</span>
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">n</span>.<span class="ruby-identifier">leaf</span>
        <span class="ruby-keyword">if</span> <span class="ruby-identifier">n</span>.<span class="ruby-identifier">kind</span> <span class="ruby-operator">=~</span> <span class="ruby-regexp">/numeric|boolean|enum/</span>
          <span class="ruby-identifier">n</span>.<span class="ruby-identifier">align</span> = <span class="ruby-identifier">@@siz</span>[<span class="ruby-identifier">n</span>.<span class="ruby-identifier">basetype</span>]
          <span class="ruby-identifier">n</span>.<span class="ruby-identifier">size</span>  = <span class="ruby-identifier">@@siz</span>[<span class="ruby-identifier">n</span>.<span class="ruby-identifier">basetype</span>]
        <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">n</span>.<span class="ruby-identifier">kind</span> <span class="ruby-operator">=~</span> <span class="ruby-regexp">/array/</span>
          <span class="ruby-identifier">n</span>.<span class="ruby-identifier">align</span> = <span class="ruby-identifier">@@siz</span>[<span class="ruby-identifier">n</span>.<span class="ruby-identifier">basetype</span>]
          <span class="ruby-identifier">n</span>.<span class="ruby-identifier">size</span>  = <span class="ruby-identifier">@@siz</span>[<span class="ruby-identifier">n</span>.<span class="ruby-identifier">basetype</span>] * <span class="ruby-identifier">n</span>.<span class="ruby-identifier">arrsize</span>
        <span class="ruby-keyword">else</span>
          <span class="ruby-identifier">raise</span> <span class="ruby-node">&quot;Unknown type in #{a}&quot;</span>
        <span class="ruby-keyword">end</span>
      <span class="ruby-keyword">else</span>
        <span class="ruby-identifier">n</span>.<span class="ruby-identifier">align</span> = (<span class="ruby-identifier">n</span>.<span class="ruby-identifier">children</span>.<span class="ruby-identifier">collect</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">c</span><span class="ruby-operator">|</span> <span class="ruby-identifier">c</span>.<span class="ruby-identifier">align</span>}).<span class="ruby-identifier">max</span>
        <span class="ruby-identifier">insert_padding</span>(<span class="ruby-identifier">n</span>)

        <span class="ruby-identifier">sizearr</span> = <span class="ruby-identifier">n</span>.<span class="ruby-identifier">children</span>.<span class="ruby-identifier">collect</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">c</span><span class="ruby-operator">|</span> <span class="ruby-identifier">c</span>.<span class="ruby-identifier">size</span>}
        <span class="ruby-keyword">case</span> <span class="ruby-identifier">n</span>.<span class="ruby-identifier">kind</span>
        <span class="ruby-keyword">when</span> <span class="ruby-string">&quot;struct&quot;</span>
          <span class="ruby-identifier">n</span>.<span class="ruby-identifier">size</span> = <span class="ruby-identifier">sizearr</span>.<span class="ruby-identifier">inject</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">sum</span>,<span class="ruby-identifier">e</span><span class="ruby-operator">|</span> <span class="ruby-identifier">sum</span><span class="ruby-operator">+</span><span class="ruby-identifier">e</span>}
        <span class="ruby-keyword">when</span> <span class="ruby-string">&quot;union&quot;</span>
          <span class="ruby-identifier">n</span>.<span class="ruby-identifier">size</span> = <span class="ruby-identifier">sizearr</span>.<span class="ruby-identifier">max</span>
        <span class="ruby-keyword">when</span> <span class="ruby-string">&quot;array&quot;</span>
          <span class="ruby-keyword">if</span> <span class="ruby-identifier">n</span>.<span class="ruby-identifier">basetype</span> <span class="ruby-operator">=~</span> <span class="ruby-regexp">/struct/</span>
            <span class="ruby-identifier">n</span>.<span class="ruby-identifier">size</span> = (<span class="ruby-identifier">sizearr</span>.<span class="ruby-identifier">inject</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">sum</span>,<span class="ruby-identifier">e</span><span class="ruby-operator">|</span> <span class="ruby-identifier">sum</span><span class="ruby-operator">+</span><span class="ruby-identifier">e</span>}) * <span class="ruby-identifier">n</span>.<span class="ruby-identifier">arrsize</span>
          <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">n</span>.<span class="ruby-identifier">basetype</span> <span class="ruby-operator">=~</span> <span class="ruby-regexp">/union/</span>
            <span class="ruby-identifier">n</span>.<span class="ruby-identifier">size</span> = <span class="ruby-identifier">sizearr</span>.<span class="ruby-identifier">max</span> * <span class="ruby-identifier">n</span>.<span class="ruby-identifier">arrsize</span>
          <span class="ruby-keyword">end</span>
        <span class="ruby-keyword">end</span>

      <span class="ruby-keyword">end</span>
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">n</span>.<span class="ruby-identifier">s_u_name</span> <span class="ruby-operator">=~</span> <span class="ruby-regexp">/__ANON__/</span>
        <span class="ruby-keyword">if</span> <span class="ruby-identifier">n</span>.<span class="ruby-identifier">kind</span> <span class="ruby-operator">=~</span> <span class="ruby-regexp">/array/</span>
          <span class="ruby-identifier">n</span>.<span class="ruby-identifier">s_u_name</span> = <span class="ruby-node">&quot;Anonymous_#{n.data.up}_#{get_anon_ext}&quot;</span>
        <span class="ruby-keyword">else</span>
          <span class="ruby-identifier">n</span>.<span class="ruby-identifier">s_u_name</span> = <span class="ruby-node">&quot;Anonymous_#{n.kind.up}_#{get_anon_ext}&quot;</span>
        <span class="ruby-keyword">end</span>
      <span class="ruby-keyword">end</span>         
    <span class="ruby-keyword">end</span>
    <span class="ruby-identifier">b</span>[<span class="ruby-string">&quot;tree&quot;</span>].<span class="ruby-identifier">align</span> = (<span class="ruby-identifier">b</span>[<span class="ruby-string">&quot;tree&quot;</span>].<span class="ruby-identifier">children</span>[<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">-1</span>].<span class="ruby-identifier">collect</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">c</span><span class="ruby-operator">|</span> <span class="ruby-identifier">c</span>.<span class="ruby-identifier">align</span>}).<span class="ruby-identifier">max</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- decorate_grove-source -->
            
          </div>

          

          
        </div><!-- decorate_grove-method -->

      
        <div id="generate_signal_classes-method" class="method-detail ">
          <a name="method-i-generate_signal_classes"></a>

          
          <div class="method-heading">
            <span class="method-name">generate_signal_classes</span><span
              class="method-args">(atable, tables, outfile, sorted_constant_name, sorted_signals, sorted_other_constant)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Generate the signal classes</p>
            

            
            <div class="method-source-code" id="generate_signal_classes-source">
<pre>
<span class="ruby-comment"># File sigpa/python/back.rb, line 317</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">generate_signal_classes</span>(<span class="ruby-identifier">atable</span>, 
                            <span class="ruby-identifier">tables</span>, 
                            <span class="ruby-identifier">outfile</span>, 
                            <span class="ruby-identifier">sorted_constant_name</span>,
                            <span class="ruby-identifier">sorted_signals</span>, 
                            <span class="ruby-identifier">sorted_other_constant</span>)

  <span class="ruby-identifier">parts</span> = <span class="ruby-identifier">outfile</span>.<span class="ruby-identifier">split</span>(<span class="ruby-string">'/'</span>)
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">parts</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">==</span> <span class="ruby-value">1</span>
    <span class="ruby-identifier">directory</span>, <span class="ruby-identifier">signal_definition_file</span> = <span class="ruby-string">&quot;.&quot;</span>, <span class="ruby-identifier">parts</span>[<span class="ruby-value">0</span>]
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">directory</span>, <span class="ruby-identifier">signal_definition_file</span> = <span class="ruby-identifier">parts</span>[<span class="ruby-value">0</span><span class="ruby-operator">..</span><span class="ruby-identifier">parts</span>.<span class="ruby-identifier">length</span><span class="ruby-operator">-</span><span class="ruby-value">2</span>].<span class="ruby-identifier">join</span>(<span class="ruby-string">&quot;/&quot;</span>), <span class="ruby-identifier">parts</span>[<span class="ruby-value">-1</span>]
  <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Create director(ies) as needed</span>
  <span class="ruby-constant">FileUtils</span>.<span class="ruby-identifier">mkdir_p</span>(<span class="ruby-identifier">directory</span>) <span class="ruby-keyword">unless</span> <span class="ruby-constant">File</span>.<span class="ruby-identifier">directory?</span>(<span class="ruby-identifier">directory</span>)


  <span class="ruby-identifier">ofname</span> = <span class="ruby-node">&quot;#{directory}/#{signal_definition_file}&quot;</span>
  <span class="ruby-identifier">f</span> = <span class="ruby-constant">File</span>.<span class="ruby-identifier">open</span>(<span class="ruby-identifier">ofname</span>, <span class="ruby-string">&quot;w&quot;</span>)
  <span class="ruby-keyword">begin</span>
    <span class="ruby-identifier">f</span>.<span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;# #{signal_definition_file} - Signal description\n&quot;</span>
    <span class="ruby-identifier">f</span>.<span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;# ----------------------------------------------------------------\n&quot;</span>
    <span class="ruby-identifier">f</span>.<span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;# WARNING: Do not modify this file. It is automatically generated\n&quot;</span>
    <span class="ruby-identifier">f</span>.<span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;#          from signal files. Any modification will be lost the\n&quot;</span>
    <span class="ruby-identifier">f</span>.<span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;#          next time the file is generated.\n&quot;</span>
    <span class="ruby-identifier">f</span>.<span class="ruby-identifier">puts</span> <span class="ruby-string">&quot;\n&quot;</span>
    <span class="ruby-identifier">f</span>.<span class="ruby-identifier">puts</span> <span class="ruby-string">&quot;\&quot;\&quot;\&quot;\n&quot;</span>
    <span class="ruby-identifier">f</span>.<span class="ruby-identifier">puts</span> <span class="ruby-string">&quot;Signal description file generated from:\n&quot;</span>
    <span class="ruby-identifier">@@options</span>.<span class="ruby-identifier">header_files</span>.<span class="ruby-identifier">each</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">name</span><span class="ruby-operator">|</span> <span class="ruby-identifier">f</span>.<span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;    #{name}\n&quot;</span>}
    <span class="ruby-identifier">f</span>.<span class="ruby-identifier">puts</span> <span class="ruby-string">&quot;Generated by:\n&quot;</span>
    <span class="ruby-identifier">f</span>.<span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;    #{$0}\n&quot;</span>
    <span class="ruby-identifier">f</span>.<span class="ruby-identifier">puts</span> <span class="ruby-string">&quot;\&quot;\&quot;\&quot;\n\n&quot;</span>
    <span class="ruby-identifier">f</span>.<span class="ruby-identifier">puts</span> <span class="ruby-string">&quot;import ogre\n\n&quot;</span>

    <span class="ruby-comment"># Generate other constants</span>
    <span class="ruby-identifier">sorted_other_constant</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">a</span><span class="ruby-operator">|</span>
      <span class="ruby-identifier">f</span>.<span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;#{a[0]} = #{a[1]}&quot;</span>
    <span class="ruby-keyword">end</span>

    <span class="ruby-comment"># Generate enum constants</span>
    <span class="ruby-identifier">tables</span>[<span class="ruby-value">3</span>][<span class="ruby-string">'table_data'</span>].<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">e</span><span class="ruby-operator">|</span>
      <span class="ruby-identifier">f</span>.<span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;class #{e[0]}:&quot;</span>
      <span class="ruby-identifier">sorted_arr</span> = <span class="ruby-identifier">e</span>[<span class="ruby-value">1</span>][<span class="ruby-string">&quot;.values&quot;</span>].<span class="ruby-identifier">sort</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">a</span>,<span class="ruby-identifier">b</span><span class="ruby-operator">|</span> <span class="ruby-identifier">a</span>[<span class="ruby-value">1</span>]<span class="ruby-operator">&lt;=&gt;</span><span class="ruby-identifier">b</span>[<span class="ruby-value">1</span>]}
      <span class="ruby-identifier">sorted_arr</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">v</span><span class="ruby-operator">|</span>
        <span class="ruby-identifier">f</span>.<span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;    #{v[0]} = #{v[1]}&quot;</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>

    <span class="ruby-comment"># Generate classes</span>
    <span class="ruby-identifier">@@grove</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">a</span>,<span class="ruby-identifier">b</span><span class="ruby-operator">|</span>
      <span class="ruby-identifier">signal_class</span> = <span class="ruby-constant">SignalClass</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">b</span>[<span class="ruby-string">'tree'</span>], <span class="ruby-identifier">f</span>, <span class="ruby-identifier">b</span>[<span class="ruby-string">'signo'</span>], <span class="ruby-identifier">a</span>)
      <span class="ruby-identifier">ahash</span> = <span class="ruby-constant">SignalClass</span>.<span class="ruby-identifier">make_hash</span>(<span class="ruby-identifier">atable</span>)
      <span class="ruby-identifier">signal_class</span>.<span class="ruby-identifier">generate</span>(<span class="ruby-identifier">ahash</span>)
    <span class="ruby-keyword">end</span>

    <span class="ruby-comment"># Generate signal registration</span>
    <span class="ruby-identifier">f</span>.<span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;\n# ----\n&quot;</span>
    <span class="ruby-identifier">@@grove</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">a</span>,<span class="ruby-identifier">b</span><span class="ruby-operator">|</span>
      <span class="ruby-identifier">f</span>.<span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;ogre.Signal.register(#{a}.SIGNO, #{a})\n&quot;</span>
    <span class="ruby-keyword">end</span>

    <span class="ruby-identifier">f</span>.<span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;\n# End of file\n&quot;</span>
    <span class="ruby-identifier">f</span>.<span class="ruby-identifier">close</span>
  <span class="ruby-keyword">rescue</span>
    <span class="ruby-identifier">f</span>.<span class="ruby-identifier">close</span>
    <span class="ruby-constant">File</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-identifier">ofname</span>)
    <span class="ruby-identifier">raise</span>
  <span class="ruby-keyword">end</span>

<span class="ruby-keyword">end</span></pre>
            </div><!-- generate_signal_classes-source -->
            
          </div>

          

          
        </div><!-- generate_signal_classes-method -->

      
        <div id="generate_signal_description-method" class="method-detail ">
          <a name="method-i-generate_signal_description"></a>

          
          <div class="method-heading">
            <span class="method-name">generate_signal_description</span><span
              class="method-args">(atable, ctable, tables)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Generate Python class files.</p>
            

            
            <div class="method-source-code" id="generate_signal_description-source">
<pre>
<span class="ruby-comment"># File sigpa/python/back.rb, line 392</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">generate_signal_description</span>(<span class="ruby-identifier">atable</span>, <span class="ruby-identifier">ctable</span>, <span class="ruby-identifier">tables</span>)
  
  <span class="ruby-identifier">symbol_table</span>, <span class="ruby-identifier">structtag_table</span>, <span class="ruby-identifier">uniontag_table</span>, <span class="ruby-identifier">enumtag_table</span>, <span class="ruby-identifier">typedef_table</span> = <span class="ruby-identifier">tables</span>

  <span class="ruby-comment"># Go through all the constants collected during phase 1 and create four tables:</span>
  <span class="ruby-comment">#</span>
  <span class="ruby-comment"># sorted_constant_name:  all constants sorted in alphabetic order</span>
  <span class="ruby-comment"># sorted_signals:        signals in alphabetical order. Each signal consists of name, </span>
  <span class="ruby-comment">#                        associated struct name, and signal number </span>
  <span class="ruby-comment"># signal_name_hash       hash of signal names</span>
  <span class="ruby-comment"># sorted_other_constant: constants that are not signals (also alphabetical order)</span>
  
  <span class="ruby-identifier">sorted_constant_name</span> = <span class="ruby-identifier">ctable</span>.<span class="ruby-identifier">keys</span>.<span class="ruby-identifier">sort</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">key1</span>, <span class="ruby-identifier">key2</span><span class="ruby-operator">|</span> <span class="ruby-identifier">key1</span>.<span class="ruby-identifier">downcase</span> <span class="ruby-operator">&lt;=&gt;</span> <span class="ruby-identifier">key2</span>.<span class="ruby-identifier">downcase</span>}
  <span class="ruby-identifier">sorted_signals</span> = []
  <span class="ruby-identifier">sorted_other_constant</span> = []
  <span class="ruby-identifier">signal_name_hash</span> = {}
  
  <span class="ruby-identifier">sorted_constant_name</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">name</span><span class="ruby-operator">|</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">ctable</span>[<span class="ruby-identifier">name</span>].<span class="ruby-identifier">has_key?</span>(<span class="ruby-string">&quot;struct&quot;</span>)
      <span class="ruby-identifier">sorted_signals</span>.<span class="ruby-identifier">push</span>([<span class="ruby-identifier">name</span>, <span class="ruby-identifier">ctable</span>[<span class="ruby-identifier">name</span>][<span class="ruby-string">&quot;struct&quot;</span>][<span class="ruby-value">0</span>], <span class="ruby-identifier">ctable</span>[<span class="ruby-identifier">name</span>][<span class="ruby-string">&quot;value&quot;</span>]])
      <span class="ruby-identifier">signal_name_hash</span>[<span class="ruby-identifier">name</span>] = [<span class="ruby-identifier">ctable</span>[<span class="ruby-identifier">name</span>][<span class="ruby-string">&quot;struct&quot;</span>][<span class="ruby-value">0</span>] , <span class="ruby-identifier">ctable</span>[<span class="ruby-identifier">name</span>][<span class="ruby-string">&quot;value&quot;</span>]]
    <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">ctable</span>[<span class="ruby-identifier">name</span>].<span class="ruby-identifier">has_key?</span>(<span class="ruby-string">&quot;union&quot;</span>) <span class="ruby-operator">||</span> <span class="ruby-identifier">ctable</span>[<span class="ruby-identifier">name</span>].<span class="ruby-identifier">has_key?</span>(<span class="ruby-string">&quot;enum&quot;</span>)
      <span class="ruby-comment"># not used</span>
    <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">ctable</span>[<span class="ruby-identifier">name</span>].<span class="ruby-identifier">has_key?</span>(<span class="ruby-string">&quot;type&quot;</span>)
      <span class="ruby-identifier">sorted_signals</span>.<span class="ruby-identifier">push</span>([<span class="ruby-identifier">name</span>, <span class="ruby-identifier">ctable</span>[<span class="ruby-identifier">name</span>][<span class="ruby-string">&quot;type&quot;</span>][<span class="ruby-value">0</span>], <span class="ruby-identifier">ctable</span>[<span class="ruby-identifier">name</span>][<span class="ruby-string">&quot;value&quot;</span>]])
      <span class="ruby-identifier">signal_name_hash</span>[<span class="ruby-identifier">name</span>] = [<span class="ruby-identifier">ctable</span>[<span class="ruby-identifier">name</span>][<span class="ruby-string">&quot;type&quot;</span>][<span class="ruby-value">0</span>], <span class="ruby-identifier">ctable</span>[<span class="ruby-identifier">name</span>][<span class="ruby-string">&quot;value&quot;</span>]] 
    <span class="ruby-keyword">else</span>
      <span class="ruby-identifier">sorted_other_constant</span>.<span class="ruby-identifier">push</span>([<span class="ruby-identifier">name</span>, <span class="ruby-identifier">ctable</span>[<span class="ruby-identifier">name</span>][<span class="ruby-string">&quot;value&quot;</span>]])
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">make_grove</span>(<span class="ruby-identifier">structtag_table</span>, <span class="ruby-identifier">typedef_table</span>, <span class="ruby-identifier">signal_name_hash</span>)
  <span class="ruby-identifier">decorate_grove</span>()

  <span class="ruby-identifier">generate_signal_classes</span>(<span class="ruby-identifier">atable</span>, 
                          <span class="ruby-identifier">tables</span>, 
                          <span class="ruby-identifier">@@options</span>.<span class="ruby-identifier">outfile</span>, 
                          <span class="ruby-identifier">sorted_constant_name</span>,
                          <span class="ruby-identifier">sorted_signals</span>, 
                          <span class="ruby-identifier">sorted_other_constant</span>)
<span class="ruby-keyword">end</span></pre>
            </div><!-- generate_signal_description-source -->
            
          </div>

          

          
        </div><!-- generate_signal_description-method -->

      
        <div id="ind-method" class="method-detail ">
          <a name="method-i-ind"></a>

          
          <div class="method-heading">
            <span class="method-name">ind</span><span
              class="method-args">(offset = 0)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            
            

            
            <div class="method-source-code" id="ind-source">
<pre>
<span class="ruby-comment"># File sigpa/linx4py/back.rb, line 454</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">ind</span>(<span class="ruby-identifier">offset</span> = <span class="ruby-value">0</span>)
  <span class="ruby-keyword">return</span> <span class="ruby-string">&quot;    &quot;</span>*(<span class="ruby-identifier">offset</span>)
<span class="ruby-keyword">end</span></pre>
            </div><!-- ind-source -->
            
          </div>

          

          
        </div><!-- ind-method -->

      
        <div id="insert_padding-method" class="method-detail ">
          <a name="method-i-insert_padding"></a>

          
          <div class="method-heading">
            <span class="method-name">insert_padding</span><span
              class="method-args">(node)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Insert padding members in children array when necessary.  Structs can get
padding members between ordinary members, plus  an extra padding at the end
to make the struct size evenly  dividable by its alignment. Unions can only
get the end padding.</p>
            

            
            <div class="method-source-code" id="insert_padding-source">
<pre>
<span class="ruby-comment"># File sigpa/python/back.rb, line 207</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">insert_padding</span>(<span class="ruby-identifier">node</span>)
  <span class="ruby-identifier">offset</span> = <span class="ruby-value">0</span>
  <span class="ruby-identifier">ca</span> = <span class="ruby-identifier">node</span>.<span class="ruby-identifier">children</span>.<span class="ruby-identifier">clone</span>
  <span class="ruby-identifier">ind</span> = <span class="ruby-operator">-</span><span class="ruby-identifier">ca</span>.<span class="ruby-identifier">length</span>

  <span class="ruby-keyword">if</span> <span class="ruby-identifier">node</span>.<span class="ruby-identifier">kind</span>.<span class="ruby-identifier">eql?</span>(<span class="ruby-string">&quot;struct&quot;</span>) <span class="ruby-operator">||</span> 
      (<span class="ruby-identifier">node</span>.<span class="ruby-identifier">kind</span>.<span class="ruby-identifier">eql?</span>(<span class="ruby-string">&quot;array&quot;</span>) <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">node</span>.<span class="ruby-identifier">basetype</span>.<span class="ruby-identifier">eql?</span>(<span class="ruby-string">&quot;struct&quot;</span>))
    <span class="ruby-identifier">offset</span> = <span class="ruby-identifier">ca</span>[<span class="ruby-value">0</span>].<span class="ruby-identifier">size</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">ca</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">1</span>
      <span class="ruby-identifier">ca</span>[<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">-1</span>].<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">c</span><span class="ruby-operator">|</span>
        <span class="ruby-identifier">pad</span> = <span class="ruby-identifier">compute_padding</span>(<span class="ruby-identifier">offset</span>, <span class="ruby-identifier">c</span>.<span class="ruby-identifier">align</span>)
        <span class="ruby-keyword">if</span> <span class="ruby-identifier">pad</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">0</span>
          <span class="ruby-identifier">x</span> = <span class="ruby-constant">Tree</span>.<span class="ruby-identifier">new</span>(<span class="ruby-node">&quot;padding_#{@extcount}&quot;</span>, <span class="ruby-string">&quot;padding&quot;</span>, <span class="ruby-identifier">node</span>)
          <span class="ruby-identifier">x</span>.<span class="ruby-identifier">size</span> = <span class="ruby-identifier">pad</span>
          <span class="ruby-identifier">x</span>.<span class="ruby-identifier">level</span> = <span class="ruby-identifier">node</span>.<span class="ruby-identifier">level</span> <span class="ruby-operator">+</span> <span class="ruby-value">1</span>
          <span class="ruby-identifier">x</span>.<span class="ruby-identifier">leaf</span> = <span class="ruby-keyword">true</span>
          <span class="ruby-identifier">node</span>.<span class="ruby-identifier">children</span>.<span class="ruby-identifier">insert</span>(<span class="ruby-identifier">ind</span>, <span class="ruby-identifier">x</span>)
          <span class="ruby-ivar">@extcount</span> <span class="ruby-operator">+=</span> <span class="ruby-value">1</span>
        <span class="ruby-keyword">end</span>
        <span class="ruby-identifier">ind</span> <span class="ruby-operator">+=</span> <span class="ruby-value">1</span>
        <span class="ruby-identifier">offset</span> <span class="ruby-operator">+=</span> <span class="ruby-identifier">pad</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">c</span>.<span class="ruby-identifier">size</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">node</span>.<span class="ruby-identifier">kind</span>.<span class="ruby-identifier">eql?</span>(<span class="ruby-string">&quot;union&quot;</span>) <span class="ruby-operator">||</span> 
      (<span class="ruby-identifier">node</span>.<span class="ruby-identifier">kind</span>.<span class="ruby-identifier">eql?</span>(<span class="ruby-string">&quot;array&quot;</span>) <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">node</span>.<span class="ruby-identifier">basetype</span>.<span class="ruby-identifier">eql?</span>(<span class="ruby-string">&quot;union&quot;</span>))
    <span class="ruby-identifier">offset</span> = (<span class="ruby-identifier">ca</span>.<span class="ruby-identifier">collect</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">c</span><span class="ruby-operator">|</span> <span class="ruby-identifier">c</span>.<span class="ruby-identifier">size</span>}).<span class="ruby-identifier">max</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">pad</span> = <span class="ruby-identifier">compute_padding</span>(<span class="ruby-identifier">offset</span>, <span class="ruby-identifier">node</span>.<span class="ruby-identifier">align</span>)
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">pad</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">0</span>
    <span class="ruby-identifier">x</span> = <span class="ruby-constant">Tree</span>.<span class="ruby-identifier">new</span>(<span class="ruby-node">&quot;padding_#{@extcount}&quot;</span>, <span class="ruby-string">&quot;padding&quot;</span>, <span class="ruby-identifier">node</span>)
    <span class="ruby-identifier">x</span>.<span class="ruby-identifier">size</span> = <span class="ruby-identifier">pad</span>
    <span class="ruby-identifier">x</span>.<span class="ruby-identifier">level</span> = <span class="ruby-identifier">node</span>.<span class="ruby-identifier">level</span> <span class="ruby-operator">+</span> <span class="ruby-value">1</span>
    <span class="ruby-identifier">x</span>.<span class="ruby-identifier">leaf</span> = <span class="ruby-keyword">true</span>
    <span class="ruby-identifier">node</span>.<span class="ruby-identifier">children</span>.<span class="ruby-identifier">insert</span>(<span class="ruby-value">-1</span>, <span class="ruby-identifier">x</span>)
    <span class="ruby-ivar">@extcount</span> <span class="ruby-operator">+=</span> <span class="ruby-value">1</span>
    <span class="ruby-identifier">offset</span> <span class="ruby-operator">+=</span> <span class="ruby-identifier">pad</span>
    <span class="ruby-identifier">node</span>.<span class="ruby-identifier">size</span> = <span class="ruby-identifier">offset</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- insert_padding-source -->
            
          </div>

          

          
        </div><!-- insert_padding-method -->

      
        <div id="is_numeric-3F-method" class="method-detail ">
          <a name="method-i-is_numeric-3F"></a>

          
          <div class="method-heading">
            <span class="method-name">is_numeric?</span><span
              class="method-args">(elem)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            
            

            
            <div class="method-source-code" id="is_numeric-3F-source">
<pre>
<span class="ruby-comment"># File sigpa/python/back.rb, line 92</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">is_numeric?</span>(<span class="ruby-identifier">elem</span>)
  <span class="ruby-identifier">elem</span>[<span class="ruby-value">1</span>][<span class="ruby-string">&quot;.type&quot;</span>] <span class="ruby-operator">=~</span> <span class="ruby-regexp">/char|short|int|longlong|long/</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- is_numeric-3F-source -->
            
          </div>

          

          
        </div><!-- is_numeric-3F-method -->

      
        <div id="item_basetype-method" class="method-detail ">
          <a name="method-i-item_basetype"></a>

          
          <div class="method-heading">
            <span class="method-name">item_basetype</span><span
              class="method-args">(elem)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            
            

            
            <div class="method-source-code" id="item_basetype-source">
<pre>
<span class="ruby-comment"># File sigpa/python/back.rb, line 78</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">item_basetype</span>(<span class="ruby-identifier">elem</span>)
  <span class="ruby-identifier">sign</span> = <span class="ruby-string">&quot;signed&quot;</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">elem</span>[<span class="ruby-value">1</span>].<span class="ruby-identifier">has_key?</span>(<span class="ruby-string">&quot;.signed&quot;</span>)
    <span class="ruby-identifier">sign</span> = <span class="ruby-identifier">elem</span>[<span class="ruby-value">1</span>][<span class="ruby-string">&quot;.signed&quot;</span>]
  <span class="ruby-keyword">end</span>
  <span class="ruby-identifier">type</span> = <span class="ruby-identifier">elem</span>[<span class="ruby-value">1</span>][<span class="ruby-string">&quot;.type&quot;</span>]
  <span class="ruby-keyword">return</span> <span class="ruby-identifier">@@basetypes</span>[<span class="ruby-identifier">sign</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">type</span>]
<span class="ruby-keyword">end</span></pre>
            </div><!-- item_basetype-source -->
            
          </div>

          

          
        </div><!-- item_basetype-method -->

      
        <div id="item_name-method" class="method-detail ">
          <a name="method-i-item_name"></a>

          
          <div class="method-heading">
            <span class="method-name">item_name</span><span
              class="method-args">(elem)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            
            

            
            <div class="method-source-code" id="item_name-source">
<pre>
<span class="ruby-comment"># File sigpa/python/back.rb, line 70</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">item_name</span>(<span class="ruby-identifier">elem</span>)
  <span class="ruby-keyword">if</span> <span class="ruby-keyword">not</span> <span class="ruby-identifier">elem</span>[<span class="ruby-value">1</span>].<span class="ruby-identifier">has_key?</span>(<span class="ruby-string">&quot;.type_or_id_name&quot;</span>)
    <span class="ruby-keyword">return</span> <span class="ruby-string">&quot;__ANON__&quot;</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-identifier">elem</span>[<span class="ruby-value">1</span>][<span class="ruby-string">&quot;.type_or_id_name&quot;</span>] <span class="ruby-operator">=~</span> <span class="ruby-regexp">/\((.+)\): (\w+)/</span>
  <span class="ruby-keyword">return</span> <span class="ruby-node">$2</span>.<span class="ruby-identifier">clone</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- item_name-source -->
            
          </div>

          

          
        </div><!-- item_name-method -->

      
        <div id="item_type-method" class="method-detail ">
          <a name="method-i-item_type"></a>

          
          <div class="method-heading">
            <span class="method-name">item_type</span><span
              class="method-args">(elem)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            
            

            
            <div class="method-source-code" id="item_type-source">
<pre>
<span class="ruby-comment"># File sigpa/python/back.rb, line 66</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">item_type</span>(<span class="ruby-identifier">elem</span>)
  <span class="ruby-identifier">elem</span>[<span class="ruby-value">1</span>][<span class="ruby-string">&quot;.type&quot;</span>]
<span class="ruby-keyword">end</span></pre>
            </div><!-- item_type-source -->
            
          </div>

          

          
        </div><!-- item_type-method -->

      
        <div id="list_grove-method" class="method-detail ">
          <a name="method-i-list_grove"></a>

          
          <div class="method-heading">
            <span class="method-name">list_grove</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>List grove</p>
            

            
            <div class="method-source-code" id="list_grove-source">
<pre>
<span class="ruby-comment"># File sigpa/python/back.rb, line 305</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">list_grove</span>()
  <span class="ruby-identifier">@@grove</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">a</span>,<span class="ruby-identifier">b</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;\n\&quot;#{a}\&quot;&quot;</span>
    <span class="ruby-constant">Tree</span>.<span class="ruby-identifier">preorder</span>(<span class="ruby-identifier">b</span>[<span class="ruby-string">&quot;tree&quot;</span>]) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">n</span><span class="ruby-operator">|</span>
      <span class="ruby-identifier">p</span> <span class="ruby-identifier">n</span>.<span class="ruby-identifier">name</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- list_grove-source -->
            
          </div>

          

          
        </div><!-- list_grove-method -->

      
        <div id="make_grove-method" class="method-detail ">
          <a name="method-i-make_grove"></a>

          
          <div class="method-heading">
            <span class="method-name">make_grove</span><span
              class="method-args">(structtag_table, typedef_table, signal_name_hash)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Construct a grove of parse trees, representing signal structs found in the
structtag_table.</p>
            

            
            <div class="method-source-code" id="make_grove-source">
<pre>
<span class="ruby-comment"># File sigpa/python/back.rb, line 167</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">make_grove</span>(<span class="ruby-identifier">structtag_table</span>, <span class="ruby-identifier">typedef_table</span>, <span class="ruby-identifier">signal_name_hash</span>)    
  <span class="ruby-identifier">signal_name_hash</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">signal</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">structtag_table</span>[<span class="ruby-string">'table_data'</span>].<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">struct</span><span class="ruby-operator">|</span>
       <span class="ruby-keyword">if</span> <span class="ruby-identifier">signal</span>[<span class="ruby-value">1</span>][<span class="ruby-value">0</span>] <span class="ruby-operator">==</span> <span class="ruby-identifier">struct</span>[<span class="ruby-value">0</span>] <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">struct</span>[<span class="ruby-value">1</span>].<span class="ruby-identifier">has_key?</span>(<span class="ruby-string">'.type'</span>) <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">struct</span>[<span class="ruby-value">1</span>].<span class="ruby-identifier">has_key?</span>(<span class="ruby-string">'.type_or_id_name'</span>)
         <span class="ruby-identifier">name</span> = <span class="ruby-identifier">signal</span>[<span class="ruby-value">0</span>]
         <span class="ruby-identifier">root</span> = <span class="ruby-constant">Tree</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">name</span>, <span class="ruby-identifier">item_type</span>(<span class="ruby-identifier">struct</span>), <span class="ruby-keyword">nil</span>)
         <span class="ruby-identifier">@@grove</span>[<span class="ruby-identifier">name</span>] = {<span class="ruby-string">&quot;signo&quot;</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">signal</span>[<span class="ruby-value">1</span>][<span class="ruby-value">1</span>], <span class="ruby-string">&quot;tree&quot;</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">root</span>}
         <span class="ruby-identifier">create_tree</span>(<span class="ruby-identifier">root</span>, <span class="ruby-identifier">struct</span>, <span class="ruby-value">0</span>, <span class="ruby-identifier">root</span>)
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>
    <span class="ruby-identifier">typedef_table</span>[<span class="ruby-string">'table_data'</span>].<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">elem</span><span class="ruby-operator">|</span>
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">signal</span>[<span class="ruby-value">1</span>][<span class="ruby-value">0</span>] <span class="ruby-operator">==</span> <span class="ruby-identifier">elem</span>[<span class="ruby-value">0</span>] <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">elem</span>[<span class="ruby-value">1</span>].<span class="ruby-identifier">has_key?</span>(<span class="ruby-string">'.type'</span>) <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">elem</span>[<span class="ruby-value">1</span>][<span class="ruby-string">'.type'</span>] <span class="ruby-operator">=~</span> <span class="ruby-regexp">/struct/</span>
        <span class="ruby-identifier">name</span> = <span class="ruby-identifier">signal</span>[<span class="ruby-value">0</span>]
        <span class="ruby-identifier">root</span> = <span class="ruby-constant">Tree</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">name</span>, <span class="ruby-identifier">item_type</span>(<span class="ruby-identifier">elem</span>), <span class="ruby-keyword">nil</span>)
        <span class="ruby-identifier">@@grove</span>[<span class="ruby-identifier">name</span>] = {<span class="ruby-string">&quot;signo&quot;</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">signal</span>[<span class="ruby-value">1</span>][<span class="ruby-value">1</span>], <span class="ruby-string">&quot;tree&quot;</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">root</span>}
        <span class="ruby-identifier">create_tree</span>(<span class="ruby-identifier">root</span>, <span class="ruby-identifier">elem</span>, <span class="ruby-value">0</span>, <span class="ruby-identifier">root</span>)
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- make_grove-source -->
            
          </div>

          

          
        </div><!-- make_grove-method -->

      
      </div><!-- public-instance-method-details -->
    
    </div><!-- 5Buntitled-5D -->
  

  </div><!-- documentation -->

  <div id="validator-badges">
    <p><small><a href="http://validator.w3.org/check/referer">[Validate]</a></small></p>
    <p><small>Generated with the <a href="http://deveiate.org/projects/Darkfish-Rdoc/">Darkfish
      Rdoc Generator</a> 2</small>.</p>
  </div>

</body>
</html>

