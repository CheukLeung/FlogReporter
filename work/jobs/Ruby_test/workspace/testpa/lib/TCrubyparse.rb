#
# DO NOT MODIFY!!!!
# This file is automatically generated by racc 1.4.5
# from racc grammer file "TCrubyparse.y".
#

require 'racc/parser'



# For the lexer
@@latest_token = ''
@@line_number = 1
@@inputarr = []

# 3 tables
@@state_list = []
@@input_list = []
@@transitions_list = []
@@name_list = []

# To find corresponding value for a variable
@@temp_input_list = {}
@@current_state = ''
@@current_file = ''


class TCrubyparse < Racc::Parser

module_eval <<'..end TCrubyparse.y modeval..id37f803dc63', 'TCrubyparse.y', 141
   
  def initialize
    # For the lexer
    @@latest_token = ''
    @@line_number = 1
    @@inputarr = []

    # 3 tables
    @@state_list = []
    @@input_list = []
    @@transitions_list = []
    @@name_list = []

    # To find corresponding value for a variable
    @@temp_input_list = {}
    @@current_state = ''
    @@current_file = ''
  end
  
  #
  # Parser
  #
  def parse(input, options)

    @options = options
    @yydebug = true

    mode = "unreal"

    if mode == "unreal"
      @@inputarr = input.split(/\n/)
      @input = input
      do_parse
    else
      File.open("inputfile", "r") do |f|
        @input = f.readlines.join
        do_parse
      end
    end  
    # check_undefined
    return @@state_list, @@input_list, @@transitions_list, @@name_list

  end


  #
  # Lexer
  #
  def next_token
    a = []
  
    @lex_table = 
      [
       ['0[xX][a-fA-F0-9]+',			   :CONSTANT], #hex constant
       ['0[0-9]+',				   :CONSTANT], #octal constant 
       ['-?(?=\d|\.\d)\d*(\.\d*)?([Ee]([+-]?\d+))?', :CONSTANT], #integer or floating point...
       ['->', 		:PTR_OP],
       ['\:=', 		:COL_ASSIGN],
       ['State\b', 	:STATE],
       ['Transitions\b', 	:TRANSITIONS],
       ['SHORTNAME', :SHORTNAME],
       ['[_a-zA-Z]\w*', :IDENTIFIER],
      ]

    # Advance line number if a newline is seen
    if @input.match(/\A\s*(\n)\s*/)
      @@line_number += 1
    end

    # Discard white space and newlines
    @input.sub!(/\A[\s\n]+/, '')

    # Check for empty input and end of input
    if @input.empty?
      if @@latest_token == ''
        raise ParseError, "ParseError: Empty input file, terminating"
      else
        puts "End of input" if @options.debug
        return [false, false]
      end
    end
    
    @found = false
    
    # Scan lex table for match
    @lex_table.each do |elem|
      if @input.sub!(/\A(#{elem[0]})/, '')
        a = [elem[1], $1]
        @found = true
        break
      end
    end
      
    # Assume token is first single char in input
    if !@found 
      if @input.sub!(/(\A.)/, '')
        a = [$1, $1]
      end
    end

    if a[0].is_a?(Symbol)
      @@latest_token = a[0].id2name
    else
      @@latest_token = a[0]
    end

    return a

  end

  def on_error(t, val, vstack)
    args = "parse error on value " +
                            val.inspect + ' ' + token_to_str(t) + "\n"
    error_report "Error near line #{@@line_number} in \'trimmedcppfile\': #{args}"
  end

..end TCrubyparse.y modeval..id37f803dc63

##### racc 1.4.5 generates ###

racc_reduce_table = [
 0, 0, :racc_error,
 1, 27, :_reduce_none,
 1, 27, :_reduce_none,
 3, 27, :_reduce_3,
 5, 29, :_reduce_4,
 1, 30, :_reduce_5,
 2, 30, :_reduce_6,
 3, 31, :_reduce_7,
 1, 32, :_reduce_8,
 2, 32, :_reduce_9,
 5, 33, :_reduce_10,
 3, 34, :_reduce_11,
 1, 35, :_reduce_none,
 2, 35, :_reduce_none,
 1, 36, :_reduce_14,
 4, 36, :_reduce_15,
 3, 36, :_reduce_16,
 3, 37, :_reduce_17,
 1, 38, :_reduce_18,
 3, 38, :_reduce_19,
 1, 40, :_reduce_20,
 3, 40, :_reduce_21,
 3, 40, :_reduce_22,
 1, 28, :_reduce_23,
 3, 28, :_reduce_24,
 3, 28, :_reduce_25,
 1, 39, :_reduce_26,
 3, 39, :_reduce_27,
 1, 41, :_reduce_none,
 1, 41, :_reduce_none,
 1, 41, :_reduce_none,
 1, 41, :_reduce_none,
 1, 42, :_reduce_none,
 2, 42, :_reduce_none,
 2, 43, :_reduce_34,
 3, 43, :_reduce_35,
 5, 44, :_reduce_36,
 2, 26, :_reduce_none ]

racc_reduce_n = 38

racc_shift_n = 72

racc_action_table = [
    65,    11,    12,    32,    33,    34,    49,    64,    14,    40,
    11,    12,    30,    31,    57,    67,    63,    14,    51,    11,
    12,    11,    12,    11,    12,    39,    14,    35,    14,    28,
    14,    11,    12,    11,    12,    11,    12,    27,    14,    54,
    14,    55,    14,    11,    12,    11,    12,    11,    12,    20,
    14,    26,    14,    19,    14,    11,    12,    11,    12,    11,
    12,    18,    14,     5,    14,    16,    14,    11,    12,    11,
    12,    11,    12,     9,    14,     8,    14,     5,    14,    11,
    12,    33,    34,    33,    34,     2,    14,    68,    69,    30,
    31,    30,    31 ]

racc_action_check = [
    58,    54,    54,    22,    41,    41,    36,    58,    54,    29,
    37,    37,    22,    22,    54,    58,    58,    37,    37,    49,
    49,    33,    33,    30,    30,    28,    49,    26,    33,    18,
    30,    55,    55,    34,    34,     4,     4,    16,    55,    47,
    34,    48,     4,    14,    14,    15,    15,    40,    40,    13,
    14,    15,    15,     9,    40,    31,    31,    20,    20,    66,
    66,     8,    31,     6,    20,     5,    66,    35,    35,    69,
    69,    27,    27,     3,    35,     2,    69,     1,    27,    45,
    45,    23,    23,    42,    42,     0,    45,    59,    59,    60,
    60,    70,    70 ]

racc_action_pointer = [
    62,    70,    71,    73,    33,    54,    56,   nil,    48,    53,
   nil,   nil,   nil,    37,    41,    43,    28,   nil,    27,   nil,
    55,   nil,    -7,    64,   nil,   nil,    16,    69,     1,    -4,
    21,    53,   nil,    19,    31,    65,    -6,     8,   nil,   nil,
    45,   -13,    66,   nil,   nil,    77,   nil,    25,    36,    17,
   nil,   nil,   nil,   nil,    -1,    29,   nil,   nil,    -6,    72,
    70,   nil,   nil,   nil,   nil,   nil,    57,   nil,   nil,    67,
    72,   nil ]

racc_action_default = [
   -38,   -38,   -38,   -38,   -38,   -38,   -37,   -32,   -38,   -38,
    -8,    -2,    -1,   -38,   -38,   -34,   -38,   -33,   -38,    72,
   -38,   -20,   -38,   -23,    -9,   -35,   -38,   -38,   -38,   -38,
   -38,   -38,    -3,   -38,   -38,   -38,   -38,   -38,    -5,   -36,
   -38,   -24,   -25,   -21,   -22,   -11,   -12,   -14,   -38,   -38,
    -6,    -4,   -10,   -13,   -38,   -38,    -7,   -16,   -20,   -38,
   -26,   -18,   -17,   -31,   -28,   -29,   -38,   -30,   -15,   -38,
   -27,   -19 ]

racc_goto_table = [
    13,    22,    61,    38,    10,    41,    42,     7,    46,    45,
    21,    13,    17,    50,    25,    24,    29,    71,    53,    59,
    15,    37,    66,     6,     3,     1,    21,    21,   nil,    43,
    44,    62,   nil,   nil,   nil,   nil,    52,   nil,   nil,   nil,
   nil,   nil,   nil,   nil,   nil,    56,   nil,   nil,   nil,   nil,
    58,   nil,   nil,    70,   nil,   nil,   nil,   nil,   nil,   nil,
   nil,   nil,    21,   nil,   nil,    58 ]

racc_goto_check = [
     2,     3,    14,     6,     8,    15,    15,    18,    11,    10,
     2,     2,    18,     6,     9,     8,     2,    14,    11,    13,
     7,     5,    16,    17,     1,    19,     2,     2,   nil,     2,
     2,     6,   nil,   nil,   nil,   nil,     2,   nil,   nil,   nil,
   nil,   nil,   nil,   nil,   nil,     2,   nil,   nil,   nil,   nil,
     2,   nil,   nil,     3,   nil,   nil,   nil,   nil,   nil,   nil,
   nil,   nil,     2,   nil,   nil,     2 ]

racc_goto_pointer = [
   nil,    24,    -4,   -13,   nil,    -6,   -24,    16,     0,    -1,
   -26,   -27,   nil,   -35,   -52,   -25,   -36,    22,     6,    25 ]

racc_goto_default = [
   nil,   nil,    36,    60,     4,   nil,    48,   nil,   nil,   nil,
   nil,   nil,    47,   nil,   nil,    23,   nil,   nil,   nil,   nil ]

racc_token_table = {
 false => 0,
 Object.new => 1,
 :IDENTIFIER => 2,
 :CONSTANT => 3,
 :SHORTNAME => 4,
 :PTR_OP => 5,
 :COL_ASSIGN => 6,
 :STATE => 7,
 :TRANSITIONS => 8,
 "(" => 9,
 ")" => 10,
 ":" => 11,
 "." => 12,
 "=" => 13,
 "{" => 14,
 "}" => 15,
 "," => 16,
 "*" => 17,
 "/" => 18,
 "+" => 19,
 "-" => 20,
 ">" => 21,
 "<" => 22,
 "[" => 23,
 "]" => 24 }

racc_use_result_var = true

racc_nt_base = 25

Racc_arg = [
 racc_action_table,
 racc_action_check,
 racc_action_default,
 racc_action_pointer,
 racc_goto_table,
 racc_goto_check,
 racc_goto_default,
 racc_goto_pointer,
 racc_nt_base,
 racc_reduce_table,
 racc_token_table,
 racc_shift_n,
 racc_reduce_n,
 racc_use_result_var ]

Racc_token_to_s_table = [
'$end',
'error',
'IDENTIFIER',
'CONSTANT',
'SHORTNAME',
'PTR_OP',
'COL_ASSIGN',
'STATE',
'TRANSITIONS',
'"("',
'")"',
'":"',
'"."',
'"="',
'"{"',
'"}"',
'","',
'"*"',
'"/"',
'"+"',
'"-"',
'">"',
'"<"',
'"["',
'"]"',
'$start',
'file',
'primary_expression',
'additive_expression',
'current_state',
'state_list',
'state_item',
'input_list',
'input_item',
'current_transition',
'transitions_list',
'full_transition_item',
'part_transition_item',
'assignment_expression_list',
'assignment_expression',
'multiplicative_expression',
'assignment_operator',
'abstractcase_list',
'abstractcase',
'short_name']

Racc_debug_parser = false

##### racc system variables end #####

 # reduce 0 omitted

 # reduce 1 omitted

 # reduce 2 omitted

module_eval <<'.,.,', 'TCrubyparse.y', 18
  def _reduce_3( val, _values, result )
 return(val[1])
   result
  end
.,.,

module_eval <<'.,.,', 'TCrubyparse.y', 26
  def _reduce_4( val, _values, result )
 return(val[3])
   result
  end
.,.,

module_eval <<'.,.,', 'TCrubyparse.y', 29
  def _reduce_5( val, _values, result )
 return([val[0]])
   result
  end
.,.,

module_eval <<'.,.,', 'TCrubyparse.y', 30
  def _reduce_6( val, _values, result )
 return(val[0].push(val[1]))
   result
  end
.,.,

module_eval <<'.,.,', 'TCrubyparse.y', 33
  def _reduce_7( val, _values, result )
 return({'.module' => val[0], '.state' => val[2]})
   result
  end
.,.,

module_eval <<'.,.,', 'TCrubyparse.y', 36
  def _reduce_8( val, _values, result )
 save_input(val[0]) ; return([val[0]])
   result
  end
.,.,

module_eval <<'.,.,', 'TCrubyparse.y', 37
  def _reduce_9( val, _values, result )
 save_input(val[1]) ; return(val[0].push(val[1]))
   result
  end
.,.,

module_eval <<'.,.,', 'TCrubyparse.y', 40
  def _reduce_10( val, _values, result )
 return({'.module' => val[0], '.parameter' => val[2], '.value' => val[4]})
   result
  end
.,.,

module_eval <<'.,.,', 'TCrubyparse.y', 43
  def _reduce_11( val, _values, result )
 return(val[2])
   result
  end
.,.,

 # reduce 12 omitted

 # reduce 13 omitted

module_eval <<'.,.,', 'TCrubyparse.y', 50
  def _reduce_14( val, _values, result )
 return(val[0].push({'.empty' => 0}))
   result
  end
.,.,

module_eval <<'.,.,', 'TCrubyparse.y', 51
  def _reduce_15( val, _values, result )
 return(val[0].push(val[2]))
   result
  end
.,.,

module_eval <<'.,.,', 'TCrubyparse.y', 52
  def _reduce_16( val, _values, result )
 return(val[0].push({'.empty' => 0}))
   result
  end
.,.,

module_eval <<'.,.,', 'TCrubyparse.y', 55
  def _reduce_17( val, _values, result )
 save_current_module(val[0]) ; return([val[0],val[2]])
   result
  end
.,.,

module_eval <<'.,.,', 'TCrubyparse.y', 58
  def _reduce_18( val, _values, result )
  return([val[0]])
   result
  end
.,.,

module_eval <<'.,.,', 'TCrubyparse.y', 59
  def _reduce_19( val, _values, result )
  return(val[0].push(val[2]))
   result
  end
.,.,

module_eval <<'.,.,', 'TCrubyparse.y', 63
  def _reduce_20( val, _values, result )
 return(val[0])
   result
  end
.,.,

module_eval <<'.,.,', 'TCrubyparse.y', 64
  def _reduce_21( val, _values, result )
 i, j = to_integer(val[0], val[2]) ; return(i.to_i * j.to_i)
   result
  end
.,.,

module_eval <<'.,.,', 'TCrubyparse.y', 65
  def _reduce_22( val, _values, result )
 i, j = to_integer(val[0], val[2]) ; return(i.to_i / j.to_i)
   result
  end
.,.,

module_eval <<'.,.,', 'TCrubyparse.y', 68
  def _reduce_23( val, _values, result )
 return(val[0])
   result
  end
.,.,

module_eval <<'.,.,', 'TCrubyparse.y', 69
  def _reduce_24( val, _values, result )
 i, j = to_integer(val[0], val[2]) ; return(i.to_i + j.to_i)
   result
  end
.,.,

module_eval <<'.,.,', 'TCrubyparse.y', 70
  def _reduce_25( val, _values, result )
 i, j = to_integer(val[0], val[2]) ; return(i.to_i - j.to_i)
   result
  end
.,.,

module_eval <<'.,.,', 'TCrubyparse.y', 73
  def _reduce_26( val, _values, result )
 return(val[0])
   result
  end
.,.,

module_eval <<'.,.,', 'TCrubyparse.y', 74
  def _reduce_27( val, _values, result )
 i, j = to_integer(0, val[2]) ; return({'.parameter' => val[0], '.operator' => val[1], '.value' => j})
   result
  end
.,.,

 # reduce 28 omitted

 # reduce 29 omitted

 # reduce 30 omitted

 # reduce 31 omitted

 # reduce 32 omitted

 # reduce 33 omitted

module_eval <<'.,.,', 'TCrubyparse.y', 87
  def _reduce_34( val, _values, result )
 push_to_tables(val[0], val[1], {'.empty' => 0})
   result
  end
.,.,

module_eval <<'.,.,', 'TCrubyparse.y', 88
  def _reduce_35( val, _values, result )
 push_to_tables(val[0], val[1], val[2])
   result
  end
.,.,

module_eval <<'.,.,', 'TCrubyparse.y', 91
  def _reduce_36( val, _values, result )
set_current_name(val[3])
   result
  end
.,.,

 # reduce 37 omitted

 def _reduce_none( val, _values, result )
  result
 end

end   # class TCrubyparse


#
# Save state, input and transition into separate arrays
#
def push_to_tables(current_state, current_input_list, current_transitions)
   @@state_list.push(current_state)
   @@input_list.push(current_input_list)
   @@transitions_list.push(current_transitions)   
   @@name_list.push("#{@@current_name}")
   
end

def set_current_name(name)
   @@current_name = name
end

#
# Save current input variables and their corresponding value
#
def save_input(input_item)
   if !@@temp_input_list.has_key?("#{input_item['.module']}")
      @@temp_input_list["#{input_item['.module']}"] = { "#{input_item['.parameter']}" => input_item['.value'] }
   else
      @@temp_input_list["#{input_item['.module']}"]["#{input_item['.parameter']}"] = input_item['.value']
   end
end

#
# Keeps track of current module 
#
def save_current_module(state_module)
   @@current_module = state_module['.module']
end

#
# Find corresponding value to a parameter
#
def to_integer(i, j)
   if ((i.is_a?(String)) && (i.to_i == 0))
      if ((i_to_integer = @@temp_input_list["#{@@current_module}"]["#{i}"]) == NIL)
         i_to_integer = i
      end
      if i == 'R' # hårdkodning
         i_to_integer = 1
      end
   else
      i_to_integer = i
   end
   if ((j.is_a?(String)) && (j.to_i == 0))
      if ((j_to_integer = @@temp_input_list["#{@@current_module}"]["#{j}"]) == NIL)
         j_to_integer = j
      end
      if j == 'R' # hårdkodning
         j_to_integer = 1
      end
   else
      j_to_integer = j
   end  
   return i_to_integer, j_to_integer
end

#
# Error report gets displayed on screen. If the parameter is omitted, will report
# a Syntax Error and cite the offending line. Otherwise, the text given in the
# parameter will be cited verbatim.
#
def error_report(text="")
  if text.eql?""
    puts "Syntax Error: \"#{@@inputarr[@@line_number-1]}\""
    #if @@options.debug
      write_error_report_to_file "Syntax Error: \"#{@@inputarr[@@line_number-1]}\""
    #end
  else
    puts "#{text}"
    #if @@options.debug
      write_error_report_to_file "#{text}"
    #end
  end
end

#
# Write all parsing errors to an error file 
#
def write_error_report_to_file(text)
   File.open("errorfile", "a") do |er|
      er.write "#{text}"
   end
end
    

