require 'pp'
require 'tree'
#
# Generate the output files containing the function descriptions
#
class FunctionDescription

  #-----------------------------------------------------------------

  def initialize(atable, sorted_signals, outfile)
    @sigvars = {}
    @atable = atable
    @sorted_signals = sorted_signals
    @sorted_signals.each {|e| @sigvars[e[0]] = e[3]}
    @hfile = outfile+".h"
    @cfile = outfile+".c"
  end

  #-----------------------------------------------------------------

  def elem?(node)
    !(node.level == 0 || node.basetype =~ /SIGSELECT/ || node.kind =~ /padding|endmark/)
  end

  #-----------------------------------------------------------------

  def last?(name, subtree)
    curr = ""
    Tree.preorder(subtree) do |n|
      curr = n.name if elem?(n)
    end
    name.eql?(curr)
  end

  #-----------------------------------------------------------------

  def has_chararr?(a)
    return false if @param[a[0]]['typ'].empty?
    last_type = @param[a[0]]['typ'][-1]
    last_type.has_key?('array') && last_type['array'][0] =~ /char/ && last_type['array'][1] == 1
  end

  #-----------------------------------------------------------------

  def fold(offset, str)
    arr = []
    sp = str.split(', ')
    return arr if sp.empty?
    sp.collect! {|s| s + ", "}
    sp[-1].slice!(-2..-1)
    targ = sp[0]
    ind = 1
    loop do
      if ind == sp.length
        arr << targ
        break
      end
      if offset+targ.length+sp[ind].length < 80
        targ << sp[ind]
      else
        arr << targ
        targ = sp[ind]
      end
      ind += 1
    end
    arr
  end

  #-----------------------------------------------------------------

  def generate_header
    @u = ""
    @u +=<<ZEB
/*************************************************
*  This file was automatically generated by sigpa.
*  Any changes will be overwritten the next time
*  this program is run.
*************************************************/

ZEB
  end

  #-----------------------------------------------------------------

  def generate_h_sigman_structs
    @x = ""
    @x +=<<TRUK
struct sigentry
{
  char *signame;
  int start;
  int finish;
};

struct elementry
{
  char *name;
  int etype;
  int dent[6];
};

extern struct sigentry sigtab[#{@@jumptable.length}];
extern struct elementry elemtab[#{@@elemtable.length}];

TRUK
  end

  #-----------------------------------------------------------------

  def generate_h_includes
    @v = ""
    @v << "#include \"ose.h\"\n"
    @v << "#include \"osetypes.h\"\n\n"
  end
  
  #-----------------------------------------------------------------

  def generate_h_file
    @s = ""
    @s << generate_header
    @s << generate_h_sigman_structs
    @s << generate_h_includes

    @sorted_signals.each do |a|
      indent = 8
      outarr = fold(indent,@param[a[0]]['fpl'])
      @s << "void s_#{a[0]}(PROCESS toPid, PROCESS viaPid,\n"
      if outarr.empty?
        @s.slice!(-2..-1)
        @s << ");\n"
      else
        outarr.each_index do |i|
          @s << " "*(indent+a[0].length) + outarr[i]
          i == outarr.length-1 ? @s << ");\n" : @s << "\n"
        end
      end

      dyntext = has_chararr?(a) ? ", char *#{@param[a[0]]['spa'][-1]}" : ""
      @s << "void s_#{a[0]}_new(PROCESS toPid, PROCESS viaPid, char *key_val_str#{dyntext});\n"

      indent = 12
      outarr = fold(indent,@param[a[0]]['spl'])
      @s << "#define r_#{a[0]}( fromPid, viaPid, \\\n"
      if outarr.empty?
        @s.slice!(-4..-1)
        @s << " ) \\\n"
      else
        outarr.each_index do |i|
          @s << " "*(indent+a[0].length) + outarr[i]
          i == outarr.length-1 ? @s << ") \\\n" : @s << " \\\n"
        end
      end

      indent = 13
      outarr = fold(indent,@param[a[0]]['spl'])
      @s << "        _r_#{a[0]}( __FILE__, __LINE__, fromPid, viaPid, \\\n"
      if outarr.empty?
        @s.slice!(-4..-1)
        @s << " )\n"
      else
        outarr.each_index do |i|
          @s << " "*(indent+a[0].length) + outarr[i]
          i == outarr.length-1 ? @s << ") \n" : @s << " \\\n"
        end
      end

      indent = 9
      outarr = fold(indent,@param[a[0]]['fpl'])
      @s << "void _r_#{a[0]}(char *file, int line, PROCESS fromPid, PROCESS viaPid,\n"
      if outarr.empty?
        @s.slice!(-2..-1)
        @s << ");\n"
      else
        outarr.each_index do |i|
          @s << " "*(indent+a[0].length) + outarr[i]
          i == outarr.length-1 ? @s << ");\n" : @s << "\n"
        end
      end

      indent = 17
      outarr = fold(indent,@param[a[0]]['spl'])
      @s << "#define r_#{a[0]}_cond( fromPid, viaPid, mask, \\\n"
      if outarr.empty?
        @s.slice!(-4..-1)
        @s << " ) \\\n"
      else 
        outarr.each_index do |i|
          @s << " "*(indent+a[0].length) + outarr[i]
          i == outarr.length-1 ? @s << ") \\\n" : @s << " \\\n"
        end
      end

      indent = 18
      outarr = fold(indent,@param[a[0]]['spl'])
      @s << "        _r_#{a[0]}_cond( __FILE__, __LINE__, fromPid, viaPid, mask, \\\n"
      if outarr.empty?
        @s.slice!(-4..-1)
        @s << ")\n"
      else
        outarr.each_index do |i|
          @s << " "*(indent+a[0].length) + outarr[i]
          i == outarr.length-1 ? @s << ") \n" : @s << " \\\n"
        end
      end

      indent = 14
      outarr = fold(indent,@param[a[0]]['fpl'])
      @s << "void _r_#{a[0]}_cond(char *file, int line, PROCESS fromPid, PROCESS viaPid, unsigned int mask, \n"
      if outarr.empty?
        @s.slice!(-3..-1)
        @s << ");\n"
      else
        outarr.each_index do |i|
          @s << " "*(indent+a[0].length) + outarr[i]
          i == outarr.length-1 ? @s << ");\n" : @s << "\n"
        end
      end

      dyntext1 = has_chararr?(a) ? ", #{@param[a[0]]['spa'][-1]}" : ""
      dyntext2 = has_chararr?(a) ? ", char *#{@param[a[0]]['spa'][-1]}" : ""
      @s << "#define r_#{a[0]}_new( fromPid, viaPid, key_val_str#{dyntext1} ) \\\n"
      @s << "        _r_#{a[0]}_new( __FILE__, __LINE__, fromPid, viaPid, char *key_val_str#{dyntext})\n"
      @s << "void _r_#{a[0]}_new(char *file, int line, PROCESS fromPid, PROCESS viaPid, char *key_val_str#{dyntext2});\n\n"
    end

    @@hf.puts @s    
  end

  #-----------------------------------------------------------------

  def generate_common_functions
    @t = ""
    @t +=<<FIN
enum action { FILL_IN, COMPARE };

struct parseresult
{
  char compname[300];
  char trimmedname[300];
  int indices[3];
  int used;
};

void parsefullname(char *fullname, struct parseresult *pares)
{
  char *q;
  char st[300], ut[300];
  char *a = fullname, *b = fullname;
  char *cp1, *cp2, *x, *y, *beg, *cur, *it;
  char valstr[10];
  int count = 0;
  int i;

  while (!isgraph(*a))
    ++a;
  b = a;
  while (isgraph(*b))
  {
    st[a-fullname] = *b;
    ++b;
  }
  for(q=a;q!=b;q++)
    st[q-a] = st[q-st];
  st[b-a] = '\\0';
  strcpy(pares->trimmedname, st);

  beg = st;
  memset(ut, '\\0', 300);
  cur = ut;
  x = st;

  if ((cp1 = strchr(x, '[')) == NULL)
  {
    strcpy(ut, st);
    pares->used = 0;
  }
  else
  {  
    while ((cp1 = strchr(x, '[')) != NULL)
    {
      cp2 = strchr(x, ']');
      memset(valstr, '\\0', 10);
      for(y=cp1+1;y!=cp2;y++)
        valstr[y-cp1-1] = *y;
      pares->indices[count++] = atoi(valstr);
      pares->used = count;

      for(it=beg;it!=cp1;it++)
      {
        *cur = *it;
        ++cur;
      }
      *cur = '[';
      ++cur;
      beg = cp2;
      x = ++cp2;
    };
    strcpy(cur, cp2-1);    
  };
  strcpy(pares->compname, ut); 
};

static void locate(struct elementry elem, struct parseresult pares, int *pos, int *len)
{
  switch (elem.etype) {
    case 1:
      *pos = elem.dent[0];
      *len = elem.dent[1];
      break;
    case 2:
      *pos = elem.dent[0] + pares.indices[0]*elem.dent[1];
      *len = elem.dent[1];
      break;
    case 3:
      *pos = elem.dent[0] + pares.indices[0]*elem.dent[1] + elem.dent[2];
      *len = elem.dent[3];    
      break;
    case 4:
      *pos = elem.dent[0] + pares.indices[0]*elem.dent[1] + elem.dent[2] +
	     pares.indices[1]*elem.dent[3];
      *len = elem.dent[3];    
      break;
    case 5:
      *pos = elem.dent[0] + pares.indices[0]*elem.dent[1] + elem.dent[2] +
	     pares.indices[1]*elem.dent[3] + elem.dent[4];
      *len = elem.dent[5];    
      break;
  }
}

static int sigman(char *file, int line, enum action sel, char *key_val_str, char *signame, char *sig)
{
  char targ[500];
  char elem[80];
  char errmess[160];
  char *sym;
  char delim[] = ",=";
  char *tokens[100];
  int j, q;
  int num = 0;
  int start = 0;
  int finish = 0;
  int found;
  int status = 1;
  struct parseresult pares;

  strcpy(targ, key_val_str);
  
  if ((sym = strtok(targ, delim)) != NULL)
  {
    tokens[num++] = sym;
    while ((sym = strtok(NULL, delim)) != NULL)
      tokens[num++] = sym;
  }

  for (q=0;q<sizeof(sigtab)/sizeof(sigtab[0]);q++)
  {
    if (!strcmp(signame, sigtab[q].signame))
    {
      start = sigtab[q].start; 
      finish = sigtab[q].finish; 
      break;
    }
  }

  for(j=0;j<num-1;j+=2)
  {
    int k=0, m, n;

    found = 0;
    parsefullname(tokens[j], &pares);

    for (n=start;n<=finish;n++)
    {
      if (!strcmp(pares.compname, elemtab[n].name))
      {
        int base;
        int val;
        int res;
        int pos;
        int len;
        char *endptr;

        locate(elemtab[n], pares, &pos, &len);
        base = ((strstr(tokens[j+1], "0x") == NULL) && (strstr(tokens[j+1], "0X") == NULL)) ? 10 : 16;
        val = strtol(tokens[j+1], &endptr, base);
        if (sel == FILL_IN)
	{
          if (len == 4)
            memcpy((char *)&sig[pos], (char *)&val, len);
          else if (len == 2 || len == 1)
            memcpy((char *)&sig[pos], (&((char *)&val)[4-len]), len);
        }
        else if (sel == COMPARE)
	{
          if (len == 4)
	    res = memcmp((char *)&val, (char *)&sig[pos], len);
          else if (len == 2 || len == 1)
	    res = memcmp((&((char *)&val)[4-len]), (char *)&sig[pos], len);
          if (res)
	  {
            sprintf(&errmess[0], "Error: element \'%s\' in %s differs\\n",
                    pares.trimmedname, signame);
	    UT_ERROR_FL(file, line, E_SIG_COMPARE, errmess);
            status = 0;
          }
        }
        found = 1;
        break;
      }
    }

    if (!found)
    {
      sprintf(&errmess[0], "Error: element \'%s\' does not exist in %s!\\n",
              pares.trimmedname, signame);
      UT_ERROR_FL(file, line, E_SIG_COMPARE, errmess); 
      status = 0;
    }
  }
  return status;
}

static void errerr(char *file, int line, char *elna, char *sina)
{
  char message[160];

  sprintf(&message[0], \"Check of \\'%s\\' in %s failed.\\n\", elna, sina);
  UT_ERROR_FL(file, line, E_SIG_COMPARE, message); 
}

static int cmp_bytes(char *file, int line, void *a, void *b, int n, char *elemname, char *signame)
{
  int i;

  if ((i = !memcmp(a,b,n)) == 0)
    errerr(file, line, elemname, signame);
  return i;
}

static int cmp_simple_array(char *file, int line, void *a, void *b, int n, int arrsize,
                            char *elemname, char *signame)
{
  int i;

  if ((i = !memcmp(a,b,n*arrsize)) == 0)
    errerr(file, line, elemname, signame);
  return i;
}

static int cmp_string(char *file, int line, char *a, char *b, char *elemname, char *signame)
{
  int i;

  if ((i = !strcmp(a,b)) == 0)
    errerr(file, line, elemname, signame);
  return i;
}
    
static int cmp_bytes_cond(char *file, int line, void *a, void *b, int n, int pos, unsigned int mask, 
                          char *elemname, char *signame)
{
  int i;

  if (((1<<pos)&mask) == mask)
    return 1;
  if ((i = !memcmp(a,b,n)) == 0)
    errerr(file, line, elemname, signame);
  return i;
}

static int cmp_simple_array_cond(char *file, int line, void *a, void *b, int n, int arrsize, int pos, 
                                 unsigned int mask, char *elemname, char *signame)
{
  int i;

  if (((1<<pos)&mask) == mask)
    return 1;
  if ((i = !memcmp(a,b,n*arrsize)) == 0)
    errerr(file, line, elemname, signame);
  return i;
}

static int cmp_string_cond(char *file, int line, char *a, char *b, int pos, unsigned int mask, 
                           char *elemname, char *signame)
{
  int i;

  if (((1<<pos)&mask) == mask)
    return 1;
  if ((i = !strcmp(a,b)) == 0)
    errerr(file, line, elemname, signame);
  return i;
}
    
FIN
  end

  #-----------------------------------------------------------------

  def generate_c_includes
    @v = ""
    @v << "#include <stdio.h>\n"
    @v << "#include <string.h>\n"
    @v << "#include <stdlib.h>\n"
    @v << "#include <ctype.h>\n"
    @@options.signal_files.each do |f|
      @v << "#include \"#{f.split('/')[-1]}\"\n"
    end
    @v << "#include \"#{@@options.outfile.split('/')[-1]}.h\"\n"
    @v << "#include \"supportFunctions.h\"\n"
    @v << "\n"
  end

  #-----------------------------------------------------------------

  def generate_bytearrtables
    @k = ""
    @en = ""
    @ju = ""
    count = 0
    @@jumptable.each do |a|
      @ju << "{\"#{a[0]}\", #{a[1]}, #{a[2]}},\n"
    end
    @ju.slice!(-2..-1)
    @@elemtable.each do |a|
      elem = a[0].split('.')[1..-1].join('.')
      @en << "\{\"#{elem}\", #{a[1]}, {"
      for i in 2...a.length
        @en << "#{a[i]}, "
      end
      @en.slice!(-2..-1)
      @en << "}},\n"
    end
    @en.slice!(-2..-1)
    @k << "struct sigentry sigtab[#{@@jumptable.length}] =\n"
    @k << "{\n"
    @k << @ju
    @k << "\n};\n\n"
    @k << "struct elementry elemtab[#{@@elemtable.length}] = \n"
    @k << "{\n"
    @k << @en
    @k << "\n};\n\n"
  end

  #-----------------------------------------------------------------

  def generate_signal_union
    @t = ""
    @t << "union SIGNAL\n"
    @t << "{\n"
    @t << "  SIGSELECT sigNo;\n"
    @sorted_signals.each do |e|
      @t << "  struct #{e[1]} #{e[3]};\n"
    end
    @t << "};\n\n"
  end

  #-----------------------------------------------------------------

  def generate_proxy_stuff
    @g = ""
    @g << "#include \"sigProxy.h\"\n"
    @g << "DECLARE_proxySignalS\n\n"
  end

  #-----------------------------------------------------------------

  def generate_send_function(a)
    @t = ""
    indent = 8
    outarr = fold(indent,@param[a[0]]['fpl'])
    @t << "void s_#{a[0]}(PROCESS toPid, PROCESS viaPid,\n"
    if outarr.empty?
      @t.slice!(-2..-1)
      @t << ")\n"
    else
      outarr.each_index do |i|
        @t << " "*(indent+a[0].length) + outarr[i]
        i == outarr.length-1 ? @t << ")\n" : @t << "\n"
      end
    end

    @t << "{\n"
    @t << "  union SIGNAL *sig;\n"
    addon = has_chararr?(a) ? " + strlen(#{@param[a[0]]['spa'][-1]})" : ""
    @t << "  sig = alloc(sizeof(struct #{a[1]})#{addon}, #{a[0]});\n"
    @param[a[0]]['spa'].each_index do |ind|
      sigvar = @sigvars[a[0]]
      if ind == @param[a[0]]['spa'].length-1 && has_chararr?(a)
        @t << "  strcpy(sig->#{sigvar}.#{@param[a[0]]['spa'][ind]}, #{@param[a[0]]['spa'][ind]});\n"
      else
        if @param[a[0]]['typ'][ind].has_key?('array')
          @t << "  {\n"
          @t << "    int i;\n"
          @t << "    for(i=0;i<#{@param[a[0]]['typ'][ind]['array'][1]};i++)\n"
          @t << "      sig->#{sigvar}.#{@param[a[0]]['spa'][ind]}[i] = #{@param[a[0]]['spa'][ind]}[i];\n"
          @t << "  }\n"
        else
          @t << "  sig->#{sigvar}.#{@param[a[0]]['spa'][ind]} = #{@param[a[0]]['spa'][ind]};\n"
        end
      end
    end
    @t << "  sigProxySend(&sig, toPid, viaPid);\n"
    @t << "}\n\n"
  end

  #-----------------------------------------------------------------

  def generate_send_function_new(a)
    @t = ""
    dyntext = has_chararr?(a) ? ", char *#{@param[a[0]]['spa'][-1]}" : ""
    @t << "void s_#{a[0]}_new(PROCESS toPid, PROCESS viaPid, char *key_val_str#{dyntext})\n"
    @t << "{\n"
    @t << "  char *f = \'\\0\';\n"
    @t << "  union SIGNAL *sig;\n"
    addon = has_chararr?(a) ? " + strlen(#{@param[a[0]]['spa'][-1]})" : ""
    @t << "  sig = alloc(sizeof(struct #{a[1]})#{addon}, #{a[0]});\n"
    @t << "  if (strlen(key_val_str))\n"
    @t << "    sigman(f, 0, FILL_IN, key_val_str, \"#{a[0]}\", (char *)sig);\n"
    if has_chararr?(a)
      sigvar = @sigvars[a[0]]
      @t << "  strcpy(sig->#{sigvar}.#{@param[a[0]]['spa'][-1]}, #{@param[a[0]]['spa'][-1]});\n"
    end
    @t << "  sigProxySend(&sig, toPid, viaPid);\n"
    @t << "}\n\n"
  end

  #-----------------------------------------------------------------

  def generate_receive_function(a)
    @t = ""
    indent = 9
    outarr = fold(indent,@param[a[0]]['fpl'])
    @t << "void _r_#{a[0]}(char *file, int line, PROCESS fromPid, PROCESS viaPid,\n"
    if outarr.empty?
      @t.slice!(-2..-1)
      @t << ")\n"
    else
      outarr.each_index do |i|
        @t << " "*(indent+a[0].length) + outarr[i]
        i == outarr.length-1 ? @t << ")\n" : @t << "\n"
      end
    end
    @t << "{\n"
    @t << "  struct proxySignalS *proxySig;\n"
    @t << "  SIGSELECT sigSel[] = \{1, #{a[0]}\};\n"
    @t << "  proxySig = sigProxyReceive(sigSel, fromPid, viaPid);\n"
    @t << "  if (!proxySig)\n"
    @t << "    UT_ERROR_FL(file, line, E_SIG_TIMEOUT, \"Timeout waiting for #{a[0]}.\");\n"

    indent = 2
    @param[a[0]]['spa'].each_index do |ind|
      elem = @param[a[0]]['spa'][ind]
      etype = @param[a[0]]['typ'][ind]
      sigvar = @sigvars[a[0]]
      if etype.has_key?('simple')
        @t << " "*indent+"cmp_bytes(file, line, &#{elem}, &(proxySig->signal.#{sigvar}.#{elem}), "
        if etype['simple'] =~ /enum/
          str = @param[a[0]]['fpa'][ind].split(' ')[0..-2].join(' ')
          @t << "sizeof(#{str}), \"#{elem}\", \"#{a[0]}\");\n"
        else
          @t << "sizeof(#{etype['simple']}), \"#{elem}\", \"#{a[0]}\");\n"
        end
      elsif etype.has_key?('pointer')
        @t << " "*indent+"cmp_bytes(file, line, (void *)#{elem}, (void *)proxySig->signal.#{sigvar}.#{elem}, "
        @t << "sizeof(U32), \"#{elem}\", \"#{a[0]}\");\n"
      elsif etype.has_key?('array')
        if etype['array'][0] =~ /struct/
          @t << " "*indent+"/* Here should be code to compare an array of structs */\n"
        else   # simple
          if ((ind == @param[a[0]]['spa'].length-1) && (@param[a[0]]['typ'][ind]['array'][0] =~ /char|U8|S8/) &&
             (@param[a[0]]['typ'][ind]['array'][1] == 1)) || (@param[a[0]]['typ'][ind]['array'][0] =~ /char|U8|S8/)
            @t << " "*indent+"cmp_string(file, line, #{elem}, (char *)proxySig->signal.#{sigvar}.#{elem}, \"#{elem}\", \"#{a[0]}\" );\n"
          else
            @t << " "*indent+"cmp_simple_array(file, line, &#{elem}, &(proxySig->signal.#{sigvar}.#{elem}), "
            @t << "sizeof(#{etype['array'][0]}), #{etype['array'][1]}, \"#{elem}\", \"#{a[0]}\");\n"  
          end
        end
      elsif etype.has_key?('struct')
        @t << " "*indent+"/* Here should be code to compare a struct */\n"
      end
    end
    @t << "  free_buf((union SIGNAL **)(void *)proxySig);\n"
    @t << "}\n\n"
  end

  #-----------------------------------------------------------------

  def generate_receive_function_cond(a)
    @t = ""
    indent = 14
    outarr = fold(indent,@param[a[0]]['fpl'])
    @t << "void _r_#{a[0]}_cond(char *file, int line, PROCESS fromPid, PROCESS viaPid, unsigned int mask,\n"
    if outarr.empty?
      @t.slice!(-2..-1)
      @t << ")\n"
    else
      outarr.each_index do |i|
        @t << " "*(indent+a[0].length) + outarr[i]
        i == outarr.length-1 ? @t << ")\n" : @t << "\n"
      end
    end
    @t << "{\n"
    @t << "  struct proxySignalS *proxySig;\n"
    @t << "  SIGSELECT sigSel[] = \{1, #{a[0]}\};\n"
    @t << "  proxySig = sigProxyReceive(sigSel, fromPid, viaPid);\n"
    @t << "  if (!proxySig)\n"
    @t << "    UT_ERROR_FL(file, line, E_SIG_TIMEOUT, \"Timeout waiting for #{a[0]}.\");\n"

    indent = 2
    @param[a[0]]['spa'].each_index do |ind|
      elem = @param[a[0]]['spa'][ind]
      etype = @param[a[0]]['typ'][ind]
      sigvar = @sigvars[a[0]]
      if etype.has_key?('simple')
        @t << " "*indent+"cmp_bytes_cond(file, line, &#{elem}, &(proxySig->signal.#{sigvar}.#{elem}), "
        if etype['simple'] =~ /enum/
          str = @param[a[0]]['fpa'][ind].split(' ')[0..-2].join(' ')
          @t << "sizeof(#{str}), #{ind}, mask, \"#{elem}\", \"#{a[0]}\");\n"
        else
          @t << "sizeof(#{etype['simple']}), #{ind}, mask, \"#{elem}\", \"#{a[0]}\");\n"
        end
      elsif etype.has_key?('pointer')
        @t << " "*indent+"cmp_bytes_cond(file, line, (void *)#{elem}, (void *)proxySig->signal.#{sigvar}.#{elem}, "
        @t << "sizeof(U32), #{ind}, mask, \"#{elem}\", \"#{a[0]}\");\n"
      elsif etype.has_key?('array')
        if etype['array'][0] =~ /struct/
          @t << " "*indent+"/* Here should be code to compare an array of structs */\n"
        else   # simple
          if ((ind == @param[a[0]]['spa'].length-1) && (@param[a[0]]['typ'][ind]['array'][0] =~ /char|U8|S8/) &&
             (@param[a[0]]['typ'][ind]['array'][1] == 1)) || (@param[a[0]]['typ'][ind]['array'][0] =~ /char|U8|S8/)
            @t << " "*indent+"cmp_string_cond(file, line, #{elem}, (char *)proxySig->signal.#{sigvar}.#{elem}, #{ind}, mask, \"#{elem}\", \"#{a[0]}\");\n"
          else
            @t << " "*indent+"cmp_simple_array_cond(file, line, &#{elem}, &(proxySig->signal.#{sigvar}.#{elem}), "
            @t << "sizeof(#{etype['array'][0]}), #{etype['array'][1]}, #{ind}, mask, \"#{elem}\", \"#{a[0]}\");\n"  
          end
        end
      elsif etype.has_key?('struct')
        @t << " "*indent+"/* Here should be code to compare a struct */\n"
      end
    end
    @t << "  free_buf((union SIGNAL **)(void *)proxySig);\n"
    @t << "}\n\n"
  end

  #-----------------------------------------------------------------

  def generate_receive_function_new(a)
    @t = ""
    dyntext = has_chararr?(a) ? ", char *#{@param[a[0]]['spa'][-1]}" : ""
    @t << "void _r_#{a[0]}_new(char *file, int line, PROCESS fromPid, PROCESS viaPid, char *key_val_str#{dyntext})\n"
    @t << "{\n"
    @t << "  struct proxySignalS *proxySig;\n"
    @t << "  SIGSELECT sigSel[] = \{1, #{a[0]}\};\n"
    @t << "  proxySig = sigProxyReceive(sigSel, fromPid, viaPid);\n"
    @t << "  if (!proxySig)\n"
    @t << "    UT_ERROR_FL(file, line, E_SIG_TIMEOUT, \"Timeout waiting for #{a[0]}.\");\n"
    @t << "  if (strlen(key_val_str))\n"
    @t << "    sigman(file, line, COMPARE, key_val_str, \"#{a[0]}\", (char *)proxySig);\n"
    if has_chararr?(a)
      elem = @param[a[0]]['spa'][-1]
      sigvar = @sigvars[a[0]]
      @t << "  cmp_string(file, line, #{elem}, (char *)proxySig->signal.#{sigvar}.#{elem}, \"#{elem}\", \"#{a[0]}\" );\n"
    end
    @t << "  free_buf((union SIGNAL **)(void *)proxySig);\n"
    @t << "}\n\n"
  end

  #-----------------------------------------------------------------

  def generate_c_file
    @s = ""
    @s << generate_header
    @s << generate_c_includes
    @s << generate_bytearrtables
    @s << generate_signal_union
    @s << generate_proxy_stuff
    @s << generate_common_functions
    @sorted_signals.each do |signame|
      @s << generate_send_function(signame)
      @s << generate_send_function_new(signame)
      @s << generate_receive_function(signame)
      @s << generate_receive_function_cond(signame)
      @s << generate_receive_function_new(signame)
    end
    @@cf.puts @s
  end

  #-----------------------------------------------------------------

  def build_parameter_lists
    @param = {}

    @@grove.each do |a,b|
      @full_string = ""
      @short_string = ""
      type_desc = []
      count = 0
      Tree.preorder(b["tree"]) do |n|
        if elem?(n) && n.level == 1
          if n.kind =~ /array/
            if n.basetype.eql?("OTHER")
              typestr = "#{n.data['.type']}"
              typestr.insert(0, "#{n.data['.signed']} ") if n.data.has_key?(".signed")
              if (n.arrsize == 1) && n.data['.type'].eql?('char') && last?(n.name, b["tree"])
                @full_string << "#{typestr} *#{n.name}, "
              else
                @full_string << "#{typestr} #{n.name}[#{n.arrsize}], "
              end
              type_desc[count] = {'array' => [n.data['.type'], n.arrsize]}
            elsif n.basetype =~ /struct/
              @full_string << "struct #{n.s_u_name} #{n.name}[#{n.arrsize}], "
              type_desc[count] = {'array' => ['struct', n.arrsize, n.s_u_name]}
            else
              @full_string << "#{n.basetype} #{n.name}[#{n.arrsize}], "
              type_desc[count] = {'array' => [n.basetype, n.arrsize]}
            end
            @short_string << "#{n.name}, "
          elsif n.kind =~ /struct/
            @full_string << "struct #{n.s_u_name} #{n.name}, "
            @short_string << "#{n.name}, "
            type_desc[count] = {'struct' => n.s_u_name}
          elsif n.kind =~ /enum/
            if n.s_u_name =~ /(.+) \(Type\)/
              @full_string << $1 + " #{n.name}, "
            else
              @full_string << "enum #{n.s_u_name} #{n.name}, "
            end
            @short_string << "#{n.name}, "
            type_desc[count] = {'simple' => n.basetype}
          elsif n.kind =~ /pointer/
            @full_string << "#{n.basetype} *#{n.name}, "
            @short_string << "#{n.name}, "
            type_desc[count] = {'pointer' => n.basetype}
          else
            if n.basetype.eql?("OTHER")
              typestr = "#{n.data['.type']}"
              typestr.insert(0, "#{n.data['.signed']} ") if n.data.has_key?(".signed")
              @full_string << "#{typestr} #{n.name}, "
              type_desc[count] = {'simple' => n.data['.type']}
            else
              @full_string << "#{n.basetype} #{n.name}, "
              type_desc[count] = {'simple' => n.basetype}
            end
            @short_string << "#{n.name}, "
          end
          count += 1
        end
      end
      full_par_list = @full_string[0..-3]
      short_par_list = @short_string[0..-3]
      full_par_arr = full_par_list.split(', ')
      short_par_arr = short_par_list.split(', ')      
      @param[a] = {'fpl' => full_par_list, 'spl' => short_par_list,
                   'fpa' => full_par_arr, 'spa' => short_par_arr,
                   'typ' => type_desc}
#pp @param
    end
  end

  #-----------------------------------------------------------------

  def generate
    @@cf = File.open(@cfile, "w")
    @@hf = File.open(@hfile, "w")
    begin
      build_parameter_lists
      generate_c_file
      generate_h_file
      @@cf.close
      @@hf.close
    rescue
      @@cf.close
      @@hf.close
      File.delete(@cfile)
      File.delete(@hfile)
      raise
    end
  end

end
